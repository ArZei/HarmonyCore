;//****************************************************************************
;//
;// Title:       ArgumentDataDefinition.dbl
;//
;// Type:        Class
;//
;// Description: Define the argument data
;//
;// Author:      Richard C. Morris, Synergex Technology Evengelist
;//
;// Copyright (c) 2014, Synergex International, Inc. All rights reserved.
;//
;// Redistribution and use in source and binary forms, with or without
;// modification, are permitted provided that the following conditions are met:
;//
;// * Redistributions of source code must retain the above copyright notice,
;//   this list of conditions and the following disclaimer.
;//
;// * Redistributions in binary form must reproduce the above copyright notice,
;//   this list of conditions and the following disclaimer in the documentation
;//   and/or other materials provided with the distribution.
;//
;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;// POSSIBILITY OF SUCH DAMAGE.
;//
;//****************************************************************************

import System
import System.Collections.Generic
import System.Text
import Newtonsoft.Json
import Harmony.Core.Enumerations
import Harmony.Core.Converters
import Newtonsoft.Json.Linq

namespace Harmony.Core

	public class ArgumentDataDefinition
		public PassedValue			,@Object
		public ReturnedValue		,boolean?
		public DataType				,FieldDataType
		public ElementSize			,int?
		public DecimalPrecision		,int?
	endclass

	public class ReturnParameterDefintion
		public Position, int
		{JsonConverter(^typeof(ReturnValueConverter))}
		public Value, @ArgumentDataDefinition
	endclass

	public class ReturnValueConverter extends JsonConverter

		public override method CanConvert, boolean
		    type, @Type
		proc
            mreturn true
		endmethod


		public override property CanRead, boolean
			method get
			proc
			    mreturn true
            endmethod
		endproperty

		public override method WriteJson, void 
			writer, @JsonWriter
			value, @object
			serializer, @JsonSerializer
		proc
		
		    throw new NotImplementedException()
        endmethod

		public override method ReadJson, @object 
			reader, @JsonReader 
			objectType, @Type 
			existingValue, @object 
			serializer, @JsonSerializer 
		proc
			data result = new ArgumentDataDefinition()
            data jObj = JObject.Load(reader)
            data dataTypeField = jObj["DataType"]
            if(dataTypeField != ^null)
            begin
				result.DataType = (FieldDataType)dataTypeField.Value<long>()
                result.ReturnedValue = true
                if(result.DataType == FieldDataType.DataObjectField) then
                begin
                    data dataObjectValue = jObj["PassedValue"]
                    if(dataObjectValue == ^null)
                        throw new InvalidCastException()

                    data metadataType = DataObjectMetadataBase.LookupType((string)dataObjectValue["Type"])

                    data grfa = (string)dataObjectValue["GRFA"]
					data realValue = dataObjectValue.Value<string>((Object)"Value")
					if(realValue == ^null) then
					begin
						result.PassedValue = metadataType.MakeNew((a)Convert.FromBase64String(dataObjectValue.Value<string>((Object)"Base64Value")), grfa)
					end
					else
					begin
						result.PassedValue = metadataType.MakeNew(realValue, grfa)
					end
                end
                else if(result.DataType == FieldDataType.DataObjectCollectionField) then
                begin
                    data metadataType, @DataObjectMetadataBase
                    data tempResult = new List<DataObjectBase>()

					data dataObjectValues = (@JArray)jObj["PassedValue"]
					data dataObjectValue, @JObject
					foreach dataObjectValue in dataObjectValues
                    begin
						if(metadataType == ^null)
							metadataType = DataObjectMetadataBase.LookupType((string)dataObjectValue["Type"])

						data grfa = (string)dataObjectValue["GRFA"]
						data realValue = dataObjectValue.Value<string>((Object)"Value")
						if(realValue == ^null) then
						begin
							tempResult.Add(metadataType.MakeNew((a)Convert.FromBase64String(dataObjectValue.Value<string>((Object)"Base64Value")), grfa))
						end
						else
						begin
							tempResult.Add(metadataType.MakeNew(realValue, grfa))
						end
					end

					result.PassedValue = tempResult
                end
                else
				begin
					result.PassedValue = jObj["PassedValue"]
                end
            end

            mreturn result
		endmethod

	endclass

endnamespace
