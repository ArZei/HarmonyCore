import System.Collections.ObjectModel
import System
import System.Collections.Generic
import System.Text
import Remotion.Linq
import Remotion.Linq.Clauses
import System.Linq.Expressions
import System.Linq

namespace Harmony.Core.FileIO.Queryable

	public class QueryModelVisitor extends QueryModelVisitorBase implements IDisposable
		mQueryBuffers, @Dictionary<string, int>
		mQueryBufferTypes, @Dictionary<string, Type>
		mDataObjectProvider, @Harmony.Core.Context.IDataObjectProvider
		mChannelManager, @Harmony.Core.FileIO.IFileChannelManager
		mSelectObject, @Synergex.SynergyDE.Select.Select
		mJoinObject, @Synergex.SynergyDE.Select.JoinSelect
		mMainFromObject, @Synergex.SynergyDE.Select.From
		mWhereObject, @Synergex.SynergyDE.Select.Where
		mOnObjects, @Dictionary<IQuerySource, Synergex.SynergyDE.Select.On>
		mAdditionalFromObjects, @List<Tuple<IQuerySource, Synergex.SynergyDE.Select.From>>
		mActiveChannels, @List<int>
		mWhereBuilder, @WhereExpressionBuilder
		mParameters, @IReadOnlyDictionary<string, Object>
		mSurpriseJoinFactory, @Func<Expression, string, IQuerySource, IQuerySource, Expression>
		public method QueryModelVisitor
			surpriseJoinFactory, @Func<Expression, string, IQuerySource, IQuerySource, Expression>
			dataObjectProvider, @Harmony.Core.Context.IDataObjectProvider
			parameters, @IReadOnlyDictionary<string, Object>
		proc
			mOnObjects = new Dictionary<IQuerySource, Synergex.SynergyDE.Select.On>()
			mQueryBuffers = new Dictionary<string, int>()
			mDataObjectProvider = dataObjectProvider
			mChannelManager = dataObjectProvider.ChannelManager
			mAdditionalFromObjects = new List<Tuple<IQuerySource, Synergex.SynergyDE.Select.From>>()
			mActiveChannels = new List<int>()
			mParameters = parameters
			mQueryBufferTypes = new Dictionary<string, Type>()
			mSurpriseJoinFactory = surpriseJoinFactory
		endmethod
		
		public virtual method Dispose, void
			endparams
		proc
			data fromObject, @Tuple<IQuerySource, Synergex.SynergyDE.Select.From>
			foreach fromObject in mAdditionalFromObjects
				fromObject.Item2.Dispose()

			if(mMainFromObject != ^null)
				mMainFromObject.Dispose()

			if(mSelectObject != ^null)
				mSelectObject.Dispose()

			if(mJoinObject != ^null)
				mJoinObject.Dispose()

			data channel, int
			foreach channel in mActiveChannels
				mChannelManager.ReturnChannel(channel)

			data memoryBuffer, int
			foreach memoryBuffer in mQueryBuffers.Values
				memoryBuffer = %mem_proc(DM_FREE, memoryBuffer)
		endmethod
		
		private method GetBufferForType, int
			dataObjectType, @Type
			fromName, @string
		proc
			data fqFromName = dataObjectType.FullName + fromName
			data memoryBuffer, int
			if(!mQueryBuffers.TryGetValue(fqFromName, memoryBuffer))
			begin
				data metadataObject = DataObjectMetadataBase.LookupType(dataObjectType)
				data structureSize = metadataObject.StructureSize
				memoryBuffer = %mem_proc(DM_ALLOC | DM_STATIC, structureSize)
				mQueryBuffers.Add(fqFromName, memoryBuffer)
				mQueryBufferTypes.Add(fqFromName, dataObjectType)
			end
			mreturn memoryBuffer
		endmethod

		protected override method VisitBodyClauses, void
			bodyClauses, @ObservableCollection<IBodyClause>
			queryModel, @QueryModel 
		proc
			data whereClause = bodyClauses.OfType<WhereClause>().FirstOrDefault()
			data fromClauses = bodyClauses.OfType<AdditionalFromClause>()
			data joinClauses = bodyClauses.OfType<JoinClause>()
			data groupJoinClauses = bodyClauses.OfType<GroupJoinClause>()
			
			data fromClause, @AdditionalFromClause
			foreach fromClause in fromClauses
			begin
				VisitAdditionalFromClause(fromClause, queryModel, 0)
			end

			data joinClause, @JoinClause
			foreach joinClause in joinClauses
			begin
				VisitJoinClause(joinClause, queryModel, 0)
			end

			data groupJoinClause, @GroupJoinClause
			foreach groupJoinClause in groupJoinClauses
			begin
				VisitJoinClause(groupJoinClause.JoinClause, queryModel, groupJoinClause)
			end

			if(whereClause != ^null)
				VisitWhereClause(whereClause, queryModel, 0)
;			data i = 0
;			for i from 0 thru bodyClauses.Count
;			begin
;				bodyClauses[i].Accept(this, queryModel, i)
;			end;
		endmethod

		public override method VisitMainFromClause, void
			fromClause, @MainFromClause 
			queryModel, @QueryModel
			structure memMapper
				fld,a1
			endstructure
		proc

			data channelInfo = mDataObjectProvider.GetFileInfo(fromClause.ItemType)
			data channel = mChannelManager.GetChannel(channelInfo.Item1, channelInfo.Item2)
			mActiveChannels.Add(channel)
			data buffer = GetBufferForType(fromClause.ItemType, fromClause.ItemName)
			data metadataObject = DataObjectMetadataBase.LookupType(fromClause.ItemType)
			data structureSize = metadataObject.StructureSize
			mMainFromObject = new Synergex.SynergyDE.Select.From(channel, ^m(memMapper.fld(1:structureSize), buffer))
			;;TODO we have to signal case sensitive somehow, not sure what the mechanism will be, maybe an option during setup per key?
			data querySource = (@IQuerySource)fromClause;
			mWhereBuilder = new WhereExpressionBuilder(buffer, metadataObject, querySource, true, mParameters, lambda(target, inner, outer) { VisitJoinClauseInternal(target, inner, outer, queryModel) })
		endmethod
		
		public override method VisitAdditionalFromClause, void 
			fromClause, @AdditionalFromClause
			queryModel, @QueryModel
			index, int
			structure memMapper
				fld,a1
			endstructure
		proc
			data channelInfo = mDataObjectProvider.GetFileInfo(fromClause.ItemType)
			data channel = mChannelManager.GetChannel(channelInfo.Item1, channelInfo.Item2)
			mActiveChannels.Add(channel)
			data buffer = GetBufferForType(fromClause.ItemType, fromClause.ItemName)
			data metadataObject = DataObjectMetadataBase.LookupType(fromClause.ItemType)
			data structureSize = metadataObject.StructureSize
			data querySource, @IQuerySource, (@IQuerySource)fromClause;FindQuerySource(fromClause.FromExpression)
			mAdditionalFromObjects.Add(Tuple.Create(querySource, new Synergex.SynergyDE.Select.From(channel, ^m(memMapper.fld(1:structureSize), buffer))))
			mWhereBuilder.AddFromClause(querySource, buffer, metadataObject)
			;;TODO we have to signal case sensitive somehow, not sure what the mechanism will be, maybe an option during setup per key?
		endmethod

		public override method VisitJoinClause, void
			joinClause, @JoinClause
			queryModel, @QueryModel
			groupJoinClause, @GroupJoinClause 
		proc
			data querySource, @IQuerySource, (@IQuerySource)joinClause;FindQuerySource(joinClause.InnerSequence)
			mOnObjects.Add(querySource, mWhereBuilder.VisitForOn(Expression.Equal(joinClause.InnerKeySelector, joinClause.OuterKeySelector)))
		endmethod

		private method VisitJoinClauseInternal, void
			querySource, @IQuerySource
			outerKeySelector, @Expression
			innerKeySelector, @Expression
			queryModel, @QueryModel
			structure memMapper
			fld,a1
			endstructure
		proc
			data additionalFromObject = mAdditionalFromObjects.FirstOrDefault(lambda(item) { item.Item1 ==  querySource})
			if(additionalFromObject == ^null)
			begin
				data channelInfo = mDataObjectProvider.GetFileInfo(querySource.ItemType)
				data channel = mChannelManager.GetChannel(channelInfo.Item1, channelInfo.Item2)
				mActiveChannels.Add(channel)
				data buffer = GetBufferForType(querySource.ItemType, querySource.ItemName)
				data metadataObject = DataObjectMetadataBase.LookupType(querySource.ItemType)
				data structureSize = metadataObject.StructureSize
				mAdditionalFromObjects.Add(Tuple.Create(querySource, new Synergex.SynergyDE.Select.From(channel, ^m(memMapper.fld(1:structureSize), buffer))))
				mWhereBuilder.AddFromClause(querySource, buffer, metadataObject)
			end
			if(innerKeySelector == ^null || (innerKeySelector .is. @ConstantExpression && ((@ConstantExpression)innerKeySelector).Value == ^null)) then
			begin
				data callNode = (@MethodCallExpression)outerKeySelector
				if(callNode.Method.Name != "Property")
				begin
					throw new NotImplementedException()
				end
				data memberNameConstant = (@ConstantExpression)callNode.Arguments[1]
				data memberName = (@string)memberNameConstant.Value
				mOnObjects.Add(querySource, mWhereBuilder.VisitForOn(mSurpriseJoinFactory(outerKeySelector, memberName, querySource, queryModel.MainFromClause)))
			end
			else
			begin
				mOnObjects.Add(querySource, mWhereBuilder.VisitForOn(Expression.Equal(outerKeySelector, innerKeySelector)))
			end

			
		endmethod

		public override method VisitJoinClause, void
			joinClause, @JoinClause
			queryModel, @QueryModel
			index, int
		proc
			VisitJoinClauseInternal(joinClause, joinClause.OuterKeySelector, joinClause.InnerKeySelector, queryModel)
		endmethod
		
		public override method VisitWhereClause, void
			whereClause, @WhereClause
			queryModel, @QueryModel
			index, int
		proc
			mWhereObject = mWhereBuilder.VisitForWhere(whereClause.Predicate)
		endmethod
		
		public override method VisitOrderByClause, void
			orderByClause, @OrderByClause
			queryModel, @QueryModel
			index, int
		proc
		endmethod

		private property IsJoin, boolean
			method get
			proc
				mreturn mOnObjects.Count > 0
			endmethod
		endproperty


		private property SelectObject, @Synergex.SynergyDE.Select.Select
			method get
			proc
				if(IsJoin)
					throw new NotImplementedException()

				if(mSelectObject == ^null)
				begin
					if(mWhereObject != ^null) then
						mSelectObject = new Synergex.SynergyDE.Select.Select(mMainFromObject, mWhereObject)
					else
						mSelectObject = new Synergex.SynergyDE.Select.Select(mMainFromObject)
				end
				mreturn mSelectObject
			endmethod
		endproperty

		private property JoinObject, @Synergex.SynergyDE.Select.JoinSelect
			method get
			proc
				if(!IsJoin)
					throw new NotImplementedException()

				if(mJoinObject == ^null)
				begin
					if(mWhereObject != ^null) then
						mJoinObject = new Synergex.SynergyDE.Select.Select(FromObject, mWhereObject).Join()
					else
						mJoinObject = new Synergex.SynergyDE.Select.Select(FromObject).Join()
				end
				mreturn mJoinObject
			endmethod
		endproperty
		
		private property FromObject, @Synergex.SynergyDE.Select.From
			method get
			proc
				if(IsJoin) then
				begin
					data fromItem, @Tuple<IQuerySource, Synergex.SynergyDE.Select.From>
					data currentJoin = mMainFromObject
					foreach fromItem in mAdditionalFromObjects
					begin
						currentJoin = currentJoin.InnerJoin(fromItem.Item2, mOnObjects[fromItem.Item1])
					end
					mMainFromObject = currentJoin
					mreturn currentJoin
				end
				else
				begin
					mreturn mMainFromObject
				end
			endmethod
		endproperty
		
		public static method ExecuteSelectInternal, @IEnumerable<DataObjectBase>
			surpriseJoinFactory, @Func<Expression, string, IQuerySource, IQuerySource, Expression>
			model, @QueryModel
			tracker, @Func<DataObjectBase, DataObjectBase>
			parameters, @IReadOnlyDictionary<string, Object>
			dataObjectProvider, @Harmony.Core.Context.IDataObjectProvider
			endparams
			structure memMapper
				fld,a1
			endstructure
		proc
			data currentCount = 0 
			;;data targetCount = top ? skip + top : 0
			data result = new List<DataObjectBase>()
			disposable data modelVisitor = new QueryModelVisitor(surpriseJoinFactory, dataObjectProvider, parameters)
			model.Accept(modelVisitor)
			 
			if(!modelVisitor.IsJoin) then
			begin
				disposable data selectObject, @Synergex.SynergyDE.Select.Select, modelVisitor.SelectObject
				data memPnt, int, modelVisitor.mQueryBuffers[model.MainFromClause.ItemType.FullName + model.MainFromClause.ItemName]
				data targetType, @Type, model.MainFromClause.ItemType
				data metadataObject = DataObjectMetadataBase.LookupType(targetType)
				data structureSize = metadataObject.StructureSize
				foreach ^m(memMapper.fld(1:structureSize), memPnt) in selectObject
				begin
					data grfa	,a10
					incr currentCount
					
					;;if(skip && skip > currentCount)
					;;	nextloop
						
					;;if (targetCount && currentCount > targetCount) 
					;;	exitloop
					
					data enumerator, @Synergex.SynergyDE.Select.RestrictedAlphaEnumerator, Synergex.SynergyDE.Select.Select.GetEnum()
					enumerator.CurrentRFA(grfa)
					result.Add(tracker(metadataObject.MakeNew(^m(memMapper.fld(1:structureSize), memPnt), grfa)))
				end
			end
			else
			begin 
				disposable data rows, @Synergex.SynergyDE.Select.RowEnumerator
				disposable data selectObject, @Synergex.SynergyDE.Select.JoinSelect, modelVisitor.JoinObject
				data hasMoreRows = true
				rows = selectObject.GetEnumerator()
				while(hasMoreRows)
				begin
					incr currentCount
					
					;;if(skip && skip > currentCount)
					;;	nextloop
						
					;;if (targetCount && currentCount > targetCount)
					;;	exitloop
					
					result.Add(MaterializeObject("", model.MainFromClause.ItemName, model.MainFromClause.ItemType, rows, modelVisitor, tracker))

					;;TODO only maybe increment rows enumerator
					hasMoreRows = rows.MoveNext()
				end
			end

			data enumResult, @IEnumerable<DataObjectBase>
			enumResult = result.ToArray()
			mreturn enumResult 
			
		endmethod

		private static method DependentObjectsForMaterialize, [#]KeyValuePair<string, object>
			parentItemName, @string
			itemName, @string
			rowEnumerator, @Synergex.SynergyDE.Select.RowEnumerator
			modelVisitor, @QueryModelVisitor
			tracker, @Func<DataObjectBase, DataObjectBase>
		proc
			data result = new Dictionary<string, object>()
			data kvp, KeyValuePair<string, int>
			foreach kvp in modelVisitor.mQueryBuffers
			begin
				;;TODO multi level joins here
				if(kvp.Key != itemName && kvp.Key != parentItemName)
				begin
					data shortKeyName = kvp.Key.Split(%char(46))
					if(modelVisitor.mQueryBufferTypes[kvp.Key].FullName == "System.Collections.Generic.ICollection`1") then
					begin
					end
					else ;if(kvp.Key.StartsWith(itemName))
					begin
						result.Add(shortKeyName.Last(), MaterializeObject(itemName, kvp.Key, modelVisitor.mQueryBufferTypes[kvp.Key], rowEnumerator, modelVisitor, tracker))
					end
				end
			end
			mreturn result.ToArray()
		endmethod

		private static method MaterializeObject, @DataObjectBase
			parentItemName, @string
			itemName, @string
			itemType, @Type
			rowEnumerator, @Synergex.SynergyDE.Select.RowEnumerator
			modelVisitor, @QueryModelVisitor
			tracker, @Func<DataObjectBase, DataObjectBase>
			structure memMapper
				fld,a1
			endstructure
		proc
			data memPnt, int, modelVisitor.mQueryBuffers[itemType.FullName + itemName]
			data metadataObject = DataObjectMetadataBase.LookupType(itemType)
			data structureSize = metadataObject.StructureSize
			data grfa, a10
			rowEnumerator.Current.RowInfo(^m(memMapper.fld(1:structureSize), memPnt), grfa)
			rowEnumerator.Current.Fill(^m(memMapper.fld(1:structureSize), memPnt))
			mreturn tracker(metadataObject.MakeNew(^m(memMapper.fld(1:structureSize), memPnt), grfa, DependentObjectsForMaterialize(parentItemName, itemName, rowEnumerator, modelVisitor, tracker)))
		endmethod

	endclass

endnamespace
