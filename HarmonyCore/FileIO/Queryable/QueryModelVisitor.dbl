import System.Collections.ObjectModel
import System
import System.Collections.Generic
import System.Text
import Remotion.Linq
import Remotion.Linq.Clauses
import System.Linq.Expressions
import System.Linq

namespace Harmony.Core.FileIO.Queryable

	public class QueryModelVisitor extends QueryModelVisitorBase
		private mWhereParts, @List<object>, new List<Object>()
		private mOnParts, @List<object>, new List<Object>()
		private mOrderBy, @Tuple<FieldReference, Boolean>, ^null
		private mQuerySourceTypes, @List<Type>, new List<Type>()
		private mTypeBuffers, @List<QueryBuffer.TypeBuffer>, new List<QueryBuffer.TypeBuffer>()
		private mQuerySourceMapping, @Dictionary<IQuerySource, int>, new Dictionary<IQuerySource, int>()
		private mMakeJoinExpression, @Func<Expression, Expression, QueryModel, Expression>
		private mWhereBuilder, @WhereExpressionBuilder
		private method QueryModelVisitor
			makeJoinExpression, @Func<Expression, Expression, QueryModel, Expression>
		proc
			mMakeJoinExpression = makeJoinExpression
		endmethod

		protected override method VisitBodyClauses, void
			bodyClauses, @ObservableCollection<IBodyClause>
			queryModel, @QueryModel 
		proc
			data whereClauses = bodyClauses.OfType<WhereClause>()
			data fromClauses = bodyClauses.OfType<AdditionalFromClause>()
			data joinClauses = bodyClauses.OfType<JoinClause>()
			data groupJoinClauses = bodyClauses.OfType<GroupJoinClause>()
			
			data fromClause, @AdditionalFromClause
			foreach fromClause in fromClauses
			begin
				VisitAdditionalFromClause(fromClause, queryModel, 0)
			end

			data joinClause, @JoinClause
			foreach joinClause in joinClauses
			begin
				VisitJoinClause(joinClause, queryModel, 0)
			end

			data groupJoinClause, @GroupJoinClause
			foreach groupJoinClause in groupJoinClauses
			begin
				VisitJoinClause(groupJoinClause.JoinClause, queryModel, groupJoinClause)
			end

			data mergedWhereClause, @Expression, ^null
			data whereClause, @WhereClause
			foreach whereClause in whereClauses
			begin
				if(mergedWhereClause == ^null) then
					mergedWhereClause = whereClause.Predicate
				else
					mergedWhereClause = Expression.AndAlso(mergedWhereClause, whereClause.Predicate)
			end

			if(mergedWhereClause != ^null)
				VisitWhereClause(new WhereClause(mergedWhereClause), queryModel, 0)

		endmethod

		private method MakeTypeBuffer, @QueryBuffer.TypeBuffer
			querySource, @IQuerySource
		proc
			;data parentType = 
			;data targetField = 
			data result = new QueryBuffer.TypeBuffer()
			&	{	
			&	Metadata = DataObjectMetadataBase.LookupType(querySource.ItemType),
			&	IsCollection = true,
			&	ParentFieldName = "",
			&	DataObjectType = querySource.ItemType,
			&	JoinOn = ^null,
			&	JoinedBuffers = new List<QueryBuffer.TypeBuffer>()
			&	}
			mreturn result
		endmethod


		public override method VisitMainFromClause, void
			fromClause, @MainFromClause 
			queryModel, @QueryModel
		proc
			data querySourceFinder = new QuerySourceVisitor()
			querySourceFinder.QuerySources.Add(fromClause)
			querySourceFinder.QuerySources.AddRange(queryModel.BodyClauses.OfType<IQuerySource>())
			data whereClauses = queryModel.BodyClauses.OfType<WhereClause>()
			data clause, @WhereClause
			foreach clause in whereClauses
			begin
				querySourceFinder.Visit(clause.Predicate)
			end

			data querySource, @IQuerySource
			foreach querySource in querySourceFinder.QuerySources
			begin
				data typeBuffer = MakeTypeBuffer(querySource)
				mQuerySourceMapping.Add(querySource, mTypeBuffers.Count)
				mTypeBuffers.Add(typeBuffer)
				mQuerySourceTypes.Add(querySource.ItemType)
			end

			mWhereBuilder = new WhereExpressionBuilder(true, querySourceFinder.QuerySources)
		endmethod
		
		public override method VisitAdditionalFromClause, void 
			fromClause, @AdditionalFromClause
			queryModel, @QueryModel
			index, int
		proc

		endmethod

		private method TypeSafeEqual, @Expression
			left, @Expression
			right, @Expression
		proc
			data leftType = left.Type
			data rightType = right.Type
			if(leftType == rightType)
				mreturn Expression.Equal(left, right)
			if(leftType.IsGenericType && leftType.GetGenericTypeDefinition() == ^typeof(System.Nullable<>)) then
			begin
				mreturn Expression.Equal(left, Expression.Convert(right, leftType))
			end
			else
			begin
				mreturn Expression.Equal(Expression.Convert(left, rightType), right)
			end
		endmethod


		public override method VisitJoinClause, void
			joinClause, @JoinClause
			queryModel, @QueryModel
			groupJoinClause, @GroupJoinClause 
		proc
			data typeBuffer = mTypeBuffers[mQuerySourceMapping[joinClause]]
			typeBuffer.JoinOn = mWhereBuilder.VisitForOn(TypeSafeEqual(joinClause.InnerKeySelector, joinClause.OuterKeySelector))
		endmethod

		private static DotArray, [#]char
		static method QueryModelVisitor
		proc
			data str = "."
			DotArray = str.ToArray()
		endmethod


		private method VisitJoinClauseInternal, void
			querySource, @IQuerySource
			outerKeySelector, @Expression
			innerKeySelector, @Expression
			queryModel, @QueryModel
			structure memMapper
				fld,a1
			endstructure
		proc
			data onPart, @object
			if(innerKeySelector == ^null || (innerKeySelector .is. @ConstantExpression && ((@ConstantExpression)innerKeySelector).Value == ^null)) then
			begin
				onPart = mWhereBuilder.VisitForOn(mMakeJoinExpression(outerKeySelector, innerKeySelector, queryModel))
			end
			else
			begin
				onPart = mWhereBuilder.VisitForOn(TypeSafeEqual(outerKeySelector, innerKeySelector))
			end
			data typeBuffer = mTypeBuffers[mQuerySourceMapping[querySource]]
			typeBuffer.JoinOn = onPart
			data otherQuerySource = FindOtherQuerySource(onPart, querySource)
			if(otherQuerySource != ^null)
			begin
				data parentBuffer = mTypeBuffers[otherQuerySource.Value]
				parentBuffer.JoinedBuffers.Add(typeBuffer)
				;;TODO compiler bug here
				;typeBuffer.ParentFieldName = querySource.ItemName.Split(DotArray).Last()
				data splitArray = querySource.ItemName.Split(DotArray)
				typeBuffer.ParentFieldName = splitArray.Last()
			end
		endmethod

		private method FindOtherQuerySource, int?
			onPart, @object
			innerSource, @IQuerySource
		proc
			if(onPart .is. @ConnectorPart) then
				mreturn FindOtherQuerySource((@ConnectorPart)onPart, innerSource)
			else if(onPart .is. @ExprPart) then
				mreturn FindOtherQuerySource((@ExprPart)onPart, innerSource)
			else if(onPart .is. @FieldReference) then
				mreturn FindOtherQuerySource((@FieldReference)onPart, innerSource)
			else
				mreturn ^null
		endmethod

		private method FindOtherQuerySource, int?
			onPart, @ConnectorPart
			innerSource, @IQuerySource
		proc
			data leftResult = FindOtherQuerySource(onPart.Left, innerSource)
			data rightResult = FindOtherQuerySource(onPart.Right, innerSource)
			mreturn leftResult != ^null ? leftResult : rightResult
		endmethod

		private method FindOtherQuerySource, int?
			onPart, @ExprPart
			innerSource, @IQuerySource
		proc
			data leftResult = FindOtherQuerySource(onPart.Left, innerSource)
			data rightResult = FindOtherQuerySource(onPart.Right, innerSource)
			mreturn leftResult != ^null ? leftResult : rightResult
		endmethod

		private method FindOtherQuerySource, int?
			onPart, @FieldReference
			innerSource, @IQuerySource
		proc
			if(mQuerySourceMapping[innerSource] != onPart.QuerySourceKey) then
			begin
				mreturn onPart.QuerySourceKey
			end
			else
				mreturn ^null
		endmethod

		public override method VisitJoinClause, void
			joinClause, @JoinClause
			queryModel, @QueryModel
			index, int
		proc
			VisitJoinClauseInternal(joinClause, joinClause.OuterKeySelector, joinClause.InnerKeySelector, queryModel)
		endmethod
		
		public override method VisitWhereClause, void
			whereClause, @WhereClause
			queryModel, @QueryModel
			index, int
		proc
			mWhereBuilder.VisitForWhere(whereClause.Predicate, mWhereParts, mOnParts)
		endmethod
		
		public override method VisitOrderByClause, void
			orderByClause, @OrderByClause
			queryModel, @QueryModel
			index, int
		proc
		endmethod

		public static method PrepareQuery, @PreparedQueryPlan
			model, @QueryModel
			makeJoinExpression, @Func<Expression, Expression, QueryModel, Expression>
		proc
			data modelVisitor = new QueryModelVisitor(makeJoinExpression)
			model.Accept(modelVisitor)

			data isCollection = !model.ResultOperators.Any(lambda (op) { op.GetType() == ^typeof(Remotion.Linq.Clauses.ResultOperators.FirstResultOperator) })
			mreturn new PreparedQueryPlan(isCollection, modelVisitor.mWhereParts, modelVisitor.mOnParts, modelVisitor.mOrderBy, new QueryBuffer(modelVisitor.mTypeBuffers))
		endmethod

		class QuerySourceVisitor extends ExpressionVisitor
			public QuerySources, @List<IQuerySource>, new List<IQuerySource>()
			protected override method VisitMethodCall, @Expression
				node, @System.Linq.Expressions.MethodCallExpression  
				endparams
			proc
				if(node.Method.Name == "Property")
				begin
					;;this is where we can do a metadata object lookup for join
					data memberTargetParameter = (@Remotion.Linq.Clauses.Expressions.QuerySourceReferenceExpression)node.Arguments[0]
					data memberNameConstant = (@ConstantExpression)node.Arguments[1]
					;data memberTargetType, @DataObjectMetadataBase, mDataObjects[memberTargetParameter.ReferencedQuerySource]
					if(!QuerySources.Contains(memberTargetParameter.ReferencedQuerySource))
					begin
						QuerySources.Add(memberTargetParameter.ReferencedQuerySource)
					end
				end
				mreturn node
			endmethod

			protected override method VisitConstant, @Expression
				node, @ConstantExpression
			proc
				mreturn node
			endmethod

			protected override method VisitMember, @Expression
				node, @MemberExpression
			proc
				mreturn node
			endmethod

		endclass

	endclass

endnamespace
