import System.Collections.ObjectModel
import System
import System.Collections.Generic
import System.Text
import Remotion.Linq
import Remotion.Linq.Clauses
import System.Linq.Expressions
import System.Linq

namespace Harmony.Core.FileIO.Queryable

	public class QueryModelVisitor extends QueryModelVisitorBase
		private mWhereParts, @List<object>, new List<Object>()
		private mOnParts, @List<object>, new List<Object>()
		private mOrderBy, @Tuple<FieldReference, Boolean>, ^null
		private mQuerySourceTypes, @List<Type>, new List<Type>()
		private mTypeBuffers, @List<QueryBuffer.TypeBuffer>, new List<QueryBuffer.TypeBuffer>()
		private mQuerySourceMapping, @Dictionary<IQuerySource, int>, new Dictionary<IQuerySource, int>()
		private mMakeJoinExpression, @Func<Expression, Expression, QueryModel, Expression>
		private mWhereBuilder, @WhereExpressionBuilder
		private method QueryModelVisitor
			makeJoinExpression, @Func<Expression, Expression, QueryModel, Expression>
		proc
			mMakeJoinExpression = makeJoinExpression
		endmethod

		protected override method VisitBodyClauses, void
			bodyClauses, @ObservableCollection<IBodyClause>
			queryModel, @QueryModel 
		proc
			data whereClauses = bodyClauses.OfType<WhereClause>()
			data fromClauses = bodyClauses.OfType<AdditionalFromClause>()
			data joinClauses = bodyClauses.OfType<JoinClause>()
			data groupJoinClauses = bodyClauses.OfType<GroupJoinClause>()
			
			data fromClause, @AdditionalFromClause
			foreach fromClause in fromClauses
			begin
				VisitAdditionalFromClause(fromClause, queryModel, 0)
			end

			data joinClause, @JoinClause
			foreach joinClause in joinClauses
			begin
				VisitJoinClause(joinClause, queryModel, 0)
			end

			data groupJoinClause, @GroupJoinClause
			foreach groupJoinClause in groupJoinClauses
			begin
				VisitJoinClause(groupJoinClause.JoinClause, queryModel, groupJoinClause)
			end

			data mergedWhereClause, @Expression, ^null
			data whereClause, @WhereClause
			foreach whereClause in whereClauses
			begin
				if(mergedWhereClause == ^null) then
					mergedWhereClause = whereClause.Predicate
				else
					mergedWhereClause = Expression.AndAlso(mergedWhereClause, whereClause.Predicate)
			end

			if(mergedWhereClause != ^null)
				VisitWhereClause(new WhereClause(mergedWhereClause), queryModel, 0)

		endmethod

		private method GetOrMakeTypeBuffer, @QueryBuffer.TypeBuffer
			querySource, @IQuerySource
		proc
			;mQuerySourceMapping.Add(fromClause, typeBuffer)
			mreturn ^null
		endmethod


		public override method VisitMainFromClause, void
			fromClause, @MainFromClause 
			queryModel, @QueryModel
			structure memMapper
				fld,a1
			endstructure
		proc
			mWhereBuilder = new WhereExpressionBuilder(true, mQuerySourceMapping.OrderBy(lambda(kvp) { kvp.Value }).Select(lambda(kvp) { kvp.Key }).ToList())
		endmethod
		
		public override method VisitAdditionalFromClause, void 
			fromClause, @AdditionalFromClause
			queryModel, @QueryModel
			index, int
			structure memMapper
				fld,a1
			endstructure
		proc
			data typeBuffer = GetOrMakeTypeBuffer(fromClause)
			;;TODO we have to signal case sensitive somehow, not sure what the mechanism will be, maybe an option during setup per key?
		endmethod

		private method TypeSafeEqual, @Expression
			left, @Expression
			right, @Expression
		proc
			data leftType = left.Type
			data rightType = right.Type
			if(leftType == rightType)
				mreturn Expression.Equal(left, right)
			if(leftType.IsGenericType && leftType.GetGenericTypeDefinition() == ^typeof(System.Nullable<>)) then
			begin
				mreturn Expression.Equal(left, Expression.Convert(right, leftType))
			end
			else
			begin
				mreturn Expression.Equal(Expression.Convert(left, rightType), right)
			end
		endmethod


		public override method VisitJoinClause, void
			joinClause, @JoinClause
			queryModel, @QueryModel
			groupJoinClause, @GroupJoinClause 
		proc
			mOnParts.Add(mWhereBuilder.VisitForOn(TypeSafeEqual(joinClause.InnerKeySelector, joinClause.OuterKeySelector)))
		endmethod

		private method VisitJoinClauseInternal, void
			querySource, @IQuerySource
			outerKeySelector, @Expression
			innerKeySelector, @Expression
			queryModel, @QueryModel
			structure memMapper
				fld,a1
			endstructure
		proc
			if(innerKeySelector == ^null || (innerKeySelector .is. @ConstantExpression && ((@ConstantExpression)innerKeySelector).Value == ^null)) then
			begin
				mOnParts.Add(mWhereBuilder.VisitForOn(mMakeJoinExpression(outerKeySelector, innerKeySelector, queryModel)))
			end
			else
			begin
				mOnParts.Add(mWhereBuilder.VisitForOn(TypeSafeEqual(outerKeySelector, innerKeySelector)))
			end

			
		endmethod

		public override method VisitJoinClause, void
			joinClause, @JoinClause
			queryModel, @QueryModel
			index, int
		proc
			VisitJoinClauseInternal(joinClause, joinClause.OuterKeySelector, joinClause.InnerKeySelector, queryModel)
		endmethod
		
		public override method VisitWhereClause, void
			whereClause, @WhereClause
			queryModel, @QueryModel
			index, int
		proc
			mWhereBuilder.VisitForWhere(whereClause.Predicate, mWhereParts, mOnParts)
		endmethod
		
		public override method VisitOrderByClause, void
			orderByClause, @OrderByClause
			queryModel, @QueryModel
			index, int
		proc
		endmethod

		public static method PrepareQuery, @PreparedQueryPlan
			model, @QueryModel
			makeJoinExpression, @Func<Expression, Expression, QueryModel, Expression>
		proc
			data modelVisitor = new QueryModelVisitor(makeJoinExpression)
			model.Accept(modelVisitor)
			;;TODO need to detect if the result selector is FirstOrDefault or something like that
			mreturn new PreparedQueryPlan(true, modelVisitor.mWhereParts, modelVisitor.mOnParts, modelVisitor.mOrderBy, new QueryBuffer(modelVisitor.mTypeBuffers))
		endmethod


	endclass

endnamespace
