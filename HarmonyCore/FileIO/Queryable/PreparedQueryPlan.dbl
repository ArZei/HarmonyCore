import System
import System.Collections.Generic
import System.Text
import System.Linq
import Harmony.Core.Enumerations

namespace Harmony.Core.FileIO.Queryable

	internal class ExprPart
		public readwrite property Left, @object
		public readwrite property Right, @Object
		public readwrite property Op, WhereClauseOperator
	endclass

	internal class ConnectorPart
		public readwrite property Left, @object
		public readwrite property Right, @Object
		public readwrite property Op, WhereClauseConnector
	endclass

	internal class FieldReference
		public readwrite property FieldDef, @FieldDataDefinition
		public readwrite property QuerySourceKey, int
	endclass

	internal class ParameterReference
		public readwrite property Name, @string
	endclass

	public class PreparedQueryPlan
		structure memMapper
			fld,a1
		endstructure
		private mWhereParts, @List<object>
		private mOnParts, @List<object>
		private mOrderBy, @Tuple<FieldReference, Boolean>
		private mQuerySourceTypes, @List<Type>
		private mQueryBufferPrototype, @QueryBuffer

		public readwrite property IsJoin, boolean
		public readwrite property IsCollection, boolean
		public readwrite property IsKeyedRead, boolean

		public method PreparedQueryPlan
			isCollection, boolean
			whereParts, @IEnumerable<object>
			onParts, @IEnumerable<object>
			orderBy, @Tuple<FieldReference, Boolean>
			queryBufferPrototype, @QueryBuffer
		proc
			mWhereParts = whereParts.ToList()
			mOnParts = onParts.ToList()
			mOrderBy = orderBy
			mQueryBufferPrototype = queryBufferPrototype
			IsJoin = mOnParts.Count > 0
			this.IsCollection = isCollection
		endmethod

		public method ExecuteCollectionPlan<T(DataObjectBase)>, @IEnumerable<T>
			tracker, @Func<DataObjectBase, DataObjectBase>
			parameters, @IReadOnlyDictionary<string, Object>
			dataObjectProvider, @Harmony.Core.Context.IDataObjectProvider
		proc
			mreturn ^null
		endmethod

		public method ExecutePlan<T(DataObjectBase)>, T
			tracker, @Func<DataObjectBase, DataObjectBase>
			parameters, @IReadOnlyDictionary<string, Object>
			dataObjectProvider, @Harmony.Core.Context.IDataObjectProvider
		proc
			if(IsKeyedRead && !IsJoin) then
				mreturn ExecuteKeyedPlan<T>(tracker, parameters, dataObjectProvider)
			else
				mreturn ExecuteSelectPlan<T>(tracker, parameters, dataObjectProvider)
		endmethod

		public method ExecuteSelectCollectionPlan<T(DataObjectBase)>, @IEnumerable<T>
			tracker, @Func<DataObjectBase, DataObjectBase>
			parameters, @IReadOnlyDictionary<string, Object>
			dataObjectProvider, @Harmony.Core.Context.IDataObjectProvider
			
		proc
			data currentCount = 0 
			;;data targetCount = top ? skip + top : 0
			data result = new List<DataObjectBase>()
			;;dont ever use mQueryBufferPrototype for operations directly
			disposable data queryBuffer = new QueryBuffer(mQueryBufferPrototype, dataObjectProvider, parameters)
			disposable data fromObj = FromObject(queryBuffer)
			if(!IsJoin) then
			begin
				
				disposable data selectObject, @Synergex.SynergyDE.Select.Select, SelectObject(queryBuffer, fromObj, WhereObject(queryBuffer), OrderByObject(queryBuffer))
				data memPnt, int, queryBuffer.TypeBuffers[0].MemoryHandle.Value
				data metadataObject = queryBuffer.TypeBuffers[0].Metadata
				data structureSize = metadataObject.StructureSize
				data enumerator, @Synergex.SynergyDE.Select.RestrictedAlphaEnumerator
				foreach ^m(memMapper.fld(1:structureSize), memPnt) in selectObject
				begin
					data grfa	,a10
					incr currentCount
					
					;;if(skip && skip > currentCount)
					;;	nextloop
						
					;;if (targetCount && currentCount > targetCount) 
					;;	exitloop
					
					if(enumerator == ^null)
						enumerator = Synergex.SynergyDE.Select.Select.GetEnum()

					enumerator.CurrentRFA(grfa)
					result.Add(tracker(metadataObject.MakeNew(^m(memMapper.fld(1:structureSize), memPnt), grfa)))
				end
			end
			else
			begin 
				disposable data rows, @Synergex.SynergyDE.Select.RowEnumerator
				disposable data selectObject, @Synergex.SynergyDE.Select.JoinSelect, JoinObject(queryBuffer, fromObj, WhereObject(queryBuffer), OrderByObject(queryBuffer))
				data hasMoreRows = true
				rows = selectObject.GetEnumerator()
				while(hasMoreRows)
				begin
					incr currentCount
					
					;;if(skip && skip > currentCount)
					;;	nextloop
						
					;;if (targetCount && currentCount > targetCount)
					;;	exitloop
					result.Add(DataObjectMaterializer.MaterializeObject(queryBuffer.TypeBuffers[0], rows, tracker))
					hasMoreRows = rows.MoveNext()
				end
			end

			data enumResult, @IEnumerable<T>
			enumResult = result.OfType<T>().ToArray()
			mreturn enumResult 
			
		endmethod

		private method ExecuteKeyedCollectionPlan<T(DataObjectBase)>, @IEnumerable<T>
			tracker, @Func<DataObjectBase, DataObjectBase>
			parameters, @IReadOnlyDictionary<string, Object>
			dataObjectProvider, @Harmony.Core.Context.IDataObjectProvider
		proc
			data resultList = new List<T>()
			disposable data fileIO = dataObjectProvider.GetFileIO<T>()
			fileIO.KeyReference = GetKeyOfReference()
			FileIOErrorHelper.EnsureSuccess(fileIO.FindRecord(GetKeyLiteral(parameters)))	
			data result, T
			while(FileIOErrorHelper.EnsureRead(fileIO.ReadNextRecord(result)))
			begin
				resultList.Add(result)
			end

			mreturn resultList
		endmethod

		private method ExecuteKeyedPlan<T(DataObjectBase)>, T
			tracker, @Func<DataObjectBase, DataObjectBase>
			parameters, @IReadOnlyDictionary<string, Object>
			dataObjectProvider, @Harmony.Core.Context.IDataObjectProvider
		proc
			disposable data fileIO = dataObjectProvider.GetFileIO<T>()
			fileIO.KeyReference = GetKeyOfReference()
			FileIOErrorHelper.EnsureSuccess(fileIO.FindRecord(GetKeyLiteral(parameters)))	
			data result, T
			if(FileIOErrorHelper.EnsureRead(fileIO.ReadRecord(result))) then
				mreturn result
			else
				mreturn ^null
		endmethod

		private method ExecuteSelectPlan<T(DataObjectBase)>, T
			tracker, @Func<DataObjectBase, DataObjectBase>
			parameters, @IReadOnlyDictionary<string, Object>
			dataObjectProvider, @Harmony.Core.Context.IDataObjectProvider
		proc
			mreturn ExecuteSelectCollectionPlan<T>(tracker, parameters, dataObjectProvider).FirstOrDefault()
		endmethod

		private method WhereObject, @Synergex.SynergyDE.Select.Where
			queryBuf, @QueryBuffer
		proc
			mreturn ^null
		endmethod

		private method OnObject, @Synergex.SynergyDE.Select.On
			queryBuf, @QueryBuffer
			typeBuf, @QueryBuffer.TypeBuffer
		proc
			mreturn ^null
		endmethod

		private method OrderByObject, @Synergex.SynergyDE.Select.OrderBy
			queryBuf, @QueryBuffer
		proc
			mreturn ^null
		endmethod

		private method SelectObject, @Synergex.SynergyDE.Select.Select
			queryBuf, @QueryBuffer
			fromObject, @Synergex.SynergyDE.Select.From
			whereObject, @Synergex.SynergyDE.Select.Where
			orderObject, @Synergex.SynergyDE.Select.OrderBy
		proc
			if(IsJoin)
				throw new NotImplementedException()

			if(whereObject != ^null) then
				mreturn new Synergex.SynergyDE.Select.Select(fromObject, whereObject)
			else
				mreturn new Synergex.SynergyDE.Select.Select(fromObject)

		endmethod

		private method JoinObject, @Synergex.SynergyDE.Select.JoinSelect
			queryBuf, @QueryBuffer
			fromObject, @Synergex.SynergyDE.Select.From
			whereObject, @Synergex.SynergyDE.Select.Where
			orderObject, @Synergex.SynergyDE.Select.OrderBy
		proc
			if(!IsJoin)
				throw new NotImplementedException()

			if(whereObject != ^null) then
				mreturn new Synergex.SynergyDE.Select.Select(fromObject, whereObject).Join()
			else
				mreturn new Synergex.SynergyDE.Select.Select(fromObject).Join()

		endmethod
		
		private method FromObject, @Synergex.SynergyDE.Select.From
			queryBuf, @QueryBuffer
		proc
			data fromItem, @QueryBuffer.TypeBuffer
			data currentJoin, @Synergex.SynergyDE.Select.From, ^null
			foreach fromItem in mQueryBufferPrototype.TypeBuffers
			begin
				;;TODO there is a bug here when using ^m(fromItem.MemoryHandle.Value) directly but its not easy to repro
				;data memPtr, i4, fromItem.MemoryHandle.Value
				data madeJoin = new Synergex.SynergyDE.Select.From(fromItem.IOChannel.Value, ^m(fromItem.MemoryHandle.Value))
				if(currentJoin == ^null) then
				begin
					currentJoin = madeJoin
				end
				else
				begin
					currentJoin = currentJoin.InnerJoin(madeJoin, OnObject(queryBuf, fromItem))
				end
			end
			mreturn currentJoin
			
		endmethod

		private method GetKeyLiteral, a
			params, @IReadOnlyDictionary<string, Object>
		proc
			mreturn ""
		endmethod

		private method GetKeyOfReference, short
		proc
			data mainTypeBuffer = mQueryBufferPrototype.TypeBuffers[0]
			if(mWhereParts.Count != 1) then
				mreturn 0
			else
			begin
				data wherePart = mWhereParts[0]
				data keyFieldSegments = new List<string>()
				GetWhereFieldNames(keyFieldSegments, wherePart)
				mreturn mainTypeBuffer.Metadata.GetKeyNumberByFieldNames(keyFieldSegments.ToArray()).Value
			end
		endmethod
		
		private method GetWhereFieldNames, void
			names, @List<string>
			obj, @object
		proc
			if(obj .is. @ExprPart) then
			begin
				data exp = (@ExprPart)obj
				GetWhereFieldNames(names, exp.Left)
				GetWhereFieldNames(names, exp.Right)
			end
			else if(obj .is. @FieldReference) then
			begin
				names.Add(((@FieldReference)obj).FieldDef.LanguageName)
			end
			else if(obj .is. @ConnectorPart)
			begin
				data conPart = (@ConnectorPart)obj
				GetWhereFieldNames(names, conPart.Left)
				GetWhereFieldNames(names, conPart.Right)
			end
		endmethod

		private method GetWhereFieldValue, void
			values, @Dictionary<string, Object>
			left, @object
			right, @object
		proc
			if(left .is. @FieldReference) then
			begin
				;values.Add(((@FieldReference)obj).FieldDef.LanguageName)
			end
			else if(left .is. @ParameterReference) then
			begin
			end
			else
			begin
			end

		endmethod

		private method GetWhereFieldValues, void
			values, @Dictionary<string, Object>
			obj, @object
		proc
			if(obj .is. @ExprPart) then
			begin
				data exp = (@ExprPart)obj
				GetWhereFieldValue(values, exp.Left, exp.Right)
			end
			else if(obj .is. @ConnectorPart)
			begin
				data conPart = (@ConnectorPart)obj
				GetWhereFieldValues(values, conPart.Left)
				GetWhereFieldValues(values, conPart.Right)
			end
		endmethod

	endclass
endnamespace
