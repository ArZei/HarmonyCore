import System
import System.Collections.Generic
import System.Text
import System.Linq

namespace Harmony.Core.FileIO.Queryable

	public class DataObjectMaterializer
		private class MaterializerState
			public parentState, @DataObjectMaterializer.MaterializerState
			public typeBuf, @QueryBuffer.TypeBuffer
			public grfa, a10
			public madeItems, @List<DataObjectBase>
			public dependentItems, @Dictionary<string, Object>
			public changed, boolean
			public filled, boolean
		endclass

		public static method MaterializeObject, @IEnumerable<DataObjectBase>
			typeBuf, @QueryBuffer.TypeBuffer
			rowEnumerator, @Synergex.SynergyDE.Select.RowEnumerator
			tracker, @Func<DataObjectBase, DataObjectBase>
			structure memMapper
				fld,a1
			endstructure
		proc
			data materializerQueue = MakeIterationQueue(typeBuf)
			data resultState = materializerQueue.First()
			materializerQueue.Reverse()
			data matState, @DataObjectMaterializer.MaterializerState
			while(rowEnumerator.MoveNext())
			begin
				;;start at the limbs for actual object construction
				foreach matState in materializerQueue
				begin
					data memPnt, i4, matState.typeBuf.MemoryHandle.Value
					data structureSize, i4, matState.typeBuf.Metadata.StructureSize
					data changed, i4
					rowEnumerator.Current.RowInfo(^m(memMapper.fld(1:structureSize), memPnt), ,changed)
					matState.changed = changed
					if(matState.changed && matState.filled)
					begin
						;;construct the object
						data madeObject = matState.dependentItems != ^null ? 
						&	matState.typeBuf.Metadata.MakeNew(^m(memMapper.fld(1:structureSize), memPnt), matState.grfa, matState.dependentItems.ToArray()) : 
						&	matState.typeBuf.Metadata.MakeNew(^m(memMapper.fld(1:structureSize), memPnt), matState.grfa)
						;;we only need to track top level objects
						if(matState.typeBuf == typeBuf)
							tracker(madeObject)

						;;if there is a parent state and we're a collection
						;;and if madeItems is empty, add ourselves to it and then add our madeItems
						;;to our parent states, dependentItems, using typeBuf.ParentFieldName as the key
						if(matState.madeItems == ^null && matState.parentState != ^null) then
						begin
							;;we must be constructing singles, just push our madeObject into the parent
							if(matState.parentState.dependentItems.ContainsKey(matState.typeBuf.ParentFieldName))
							begin
								;;this leg should have only had one result, throw
								throw new InvalidOperationException(string.Format("Unexpected record during enumeration, additional item encountered was {0} joined to a {1} at {2}", 
								&	matState.typeBuf.DataObjectType.FullName, matState.parentState.typeBuf.DataObjectType, matState.typeBuf.ParentFieldName))
							end
							matState.parentState.dependentItems.Add(matState.typeBuf.ParentFieldName, madeObject)
						end
						else if(matState.madeItems != ^null) then
						begin
							matState.madeItems.Add(madeObject)
						end
						else
							throw new InvalidOperationException("Invalid materializer state")
					
						if(matState.parentState != ^null)
						begin
							if(matState.madeItems != ^null && matState.madeItems.Count == 1)
							begin
								matState.parentState.dependentItems.Add(matState.typeBuf.ParentFieldName, matState.madeItems)
							end
						end

						;;cleanup the materializer state for this step
						if(matState.dependentItems != ^null)
							matState.dependentItems.Clear()
					end
				
					if(matState.changed)
					begin
						matState.filled = true
						;;fill the row
						rowEnumerator.Current.RowInfo(^m(memMapper.fld(1:structureSize), memPnt), matState.grfa)
						rowEnumerator.Current.Fill(^m(memMapper.fld(1:structureSize), memPnt))
					end
				end
				;;we only want one object if we dont have a collection result
				if(!resultState.madeItems.Count == 1 && typeBuf.IsCollection)
					mreturn resultState.madeItems
			end


			;;finsh up the leftover materialization process here
			foreach matState in materializerQueue
			begin
				data memPnt, i4, matState.typeBuf.MemoryHandle.Value
				data structureSize, i4, matState.typeBuf.Metadata.StructureSize
				;;construct the object
				;;construct the object
				data madeObject = matState.dependentItems != ^null ? 
				&	matState.typeBuf.Metadata.MakeNew(^m(memMapper.fld(1:structureSize), memPnt), matState.grfa, matState.dependentItems.ToArray()) : 
				&	matState.typeBuf.Metadata.MakeNew(^m(memMapper.fld(1:structureSize), memPnt), matState.grfa)
				;;we only need to track top level objects
				if(matState.typeBuf == typeBuf)
					tracker(madeObject)

				if(matState.madeItems == ^null && matState.parentState != ^null) then
				begin
					;;we must be constructing singles, just push our madeObject into the parent
					if(matState.parentState.dependentItems.ContainsKey(matState.typeBuf.ParentFieldName))
					begin
						;;this leg should have only had one result, throw
						throw new InvalidOperationException(string.Format("Unexpected record during enumeration, additional item encountered was {0} joined to a {1} at {2}", 
						&	matState.typeBuf.DataObjectType.FullName, matState.parentState.typeBuf.DataObjectType, matState.typeBuf.ParentFieldName))
					end
					matState.parentState.dependentItems.Add(matState.typeBuf.ParentFieldName, madeObject)
				end
				else if(matState.madeItems != ^null) then
				begin
					matState.madeItems.Add(madeObject)
				end
				else
					throw new InvalidOperationException("Invalid materializer state")
					
				if(matState.parentState != ^null)
				begin
					if(matState.madeItems != ^null && matState.madeItems.Count == 1)
					begin
						matState.parentState.dependentItems.Add(matState.typeBuf.ParentFieldName, matState.madeItems)
					end
				end
			end
			mreturn resultState.madeItems
		endmethod

		private static method MakeIterationQueue, @List<DataObjectMaterializer.MaterializerState>
			source, @QueryBuffer.TypeBuffer
		proc
			data result = new List<DataObjectMaterializer.MaterializerState>()
			data q = new @Queue<DataObjectMaterializer.MaterializerState>()

			data rootState = new MaterializerState() { typeBuf = source, changed = false, filled = false, madeItems = new List<DataObjectBase>() }
			if(source.JoinedBuffers != ^null && source.JoinedBuffers.Count > 0)
				rootState.dependentItems = new Dictionary<string, Object>()

			q.Enqueue(rootState) 
			;;this is constructing a bredth first traversal list
			while(q.Count > 0)
			begin
				data current = q.Dequeue()
				data joined, @QueryBuffer.TypeBuffer
				foreach joined in current.typeBuf.JoinedBuffers
				begin
					data newMatState = new MaterializerState() { typeBuf = joined, changed = false, filled = false, parentState = current }
					if(joined.IsCollection)
						newMatState.madeItems = new List<DataObjectBase>()

					if(joined.JoinedBuffers != ^null && joined.JoinedBuffers.Count > 0)
						newMatState.dependentItems = new Dictionary<string, Object>()

					q.Enqueue(newMatState) 
				end
			end
			mreturn result
		endmethod

	endclass

endnamespace
