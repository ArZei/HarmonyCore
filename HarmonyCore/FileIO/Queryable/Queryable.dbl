import System
import System.Collections.Generic
import System.Text
import System.Linq
import System.Reflection
import System.Linq.Expressions
import Harmony.Core

namespace Harmony.Core.FileIO.Queryable

	public class QueryProvider implements IQueryProvider
		private mChannel,int
		private mDataObjectType, @Type
		public method QueryProvider
			in req channel	,int
			in req dataObjectType, @Type
			endparams
		proc
			mChannel = channel
			mDataObjectType = dataObjectType

		endmethod

		public method Execute, @object
			expression, @System.Linq.Expressions.Expression 
			isEnumerable, boolean
		proc
			data whereFinder = new InnermostWhereFinder();
			data whereExpression = whereFinder.GetInnermostWhere(expression);
			data whereLambda = ((UnaryExpression)(whereExpression.Arguments[1])).Operand;
			
			whereLambda = PartialEvaluator.Eval(whereLambda)

			;;data orderByFinder = new InnermostOrderByFinder();
			;;data orderByExpression = orderByFinder.GetInnermostOrderBy(expression);
			;;data orderByLambda = ((UnaryExpression)(orderByExpression.Arguments[1])).Operand;

			;;orderByLambda = PartialEvaluator.Eval(orderByLambda)

			;; Copy the IEnumerable places to an IQueryable.
			data queryResult = (@Object)ExecuteSelectInternal(whereLambda, ^null, 0, 0)
			mreturn queryResult
;			;; Copy the expression tree that was passed in, changing only the first 
;			;; argument of the innermost MethodCallExpression.
;			data treeCopier = new ExpressionTreeModifier(whereExpression, queryResult);
;			data newExpressionTree = treeCopier.Eval(expression);
;
;			;; This step creates an IQueryable that executes by replacing Queryable methods with Enumerable methods. 
;			if (IsEnumerable) then
;				mreturn queryResult.Provider.CreateQuery(newExpressionTree);
;			else 
;				mreturn queryResult.Provider.Execute(newExpressionTree);
		endmethod

		private method ExecuteSelectInternal, @IEnumerable<DataObjectBase>
			whereLambda, @Expression
			orderByLambda, @Expression
			top, int
			skip, int
		endparams
			structure memMapper
				fld,a1
			endstructure
		proc
			data metadataObject = DataObjectMetadataBase.LookupType(mDataObjectType)
			data structureSize = metadataObject.StructureSize
			data memPnt = %mem_proc(DM_ALLOC, structureSize)
			data currentCount = 0
			data targetCount = top ? skip + top : 0
			data result = new List<DataObjectBase>()
			data expressionBuilder = new WhereExpressionBuilder(whereLambda, memPnt, metadataObject, false)

			foreach ^m(memMapper.fld(1:structureSize), memPnt) in new Synergex.SynergyDE.Select.Select(new Synergex.SynergyDE.Select.From(mChannel, ^m(memMapper.fld(1:structureSize), memPnt)), expressionBuilder.WhereExpression)
			begin
				data grfa	,a10
				incr currentCount

				if(skip && skip > currentCount)
					nextloop

				if (targetCount && currentCount > targetCount)
					exitloop
				
				data enumerator, @Synergex.SynergyDE.Select.RestrictedAlphaEnumerator, Synergex.SynergyDE.Select.Select.GetEnum()
				enumerator.CurrentRFA(grfa)
				result.Add(metadataObject.MakeNew(^m(memMapper.fld(1:structureSize), memPnt), grfa))
			end
			data enumResult, @IEnumerable<DataObjectBase>
			enumResult = result.ToArray()
			mreturn enumResult 
		endmethod

		public method Execute, @object
			expression, @System.Linq.Expressions.Expression 
			endparams
		proc
			mreturn this.Execute(expression, false)
		endmethod
		
		public virtual method Execute<TResult>, TResult
			expression, @System.Linq.Expressions.Expression 
			endparams
		proc 
			data isEnumerable = (^typeof(TResult).Name == "IEnumerable`1");
			mreturn (TResult)this.Execute(expression, isEnumerable)
		endmethod
		
		public virtual method CreateQuery<TElement>, @IQueryable<TElement>
			expression, @System.Linq.Expressions.Expression 
			endparams
		proc
			mreturn new Query<TElement>(this, expression);
		endmethod
		
		public virtual method CreateQuery, @IQueryable
			expression, @System.Linq.Expressions.Expression 
			endparams
		proc
			data elementType = TypeHelper.GetElementType(expression.Type);
			try
				mreturn (IQueryable)Activator.CreateInstance(Type.GetType("Harmony.Core.FileIO.Queryable.Query`1").MakeGenericType(elementType), new object[#] { this, expression });
			catch (tie, @TargetInvocationException)
				throw tie.InnerException
			endtry
		endmethod

	endclass


	internal class InnermostWhereFinder extends ExpressionVisitor
    
		private innermostWhereExpression, @MethodCallExpression
    
		public method GetInnermostWhere, @MethodCallExpression
			expression, @Expression 
			endparams
		proc
			Visit(expression)
			mreturn innermostWhereExpression
		endmethod
    
		protected override method VisitMethodCall, @Expression
			expression, @MethodCallExpression 
			endparams
		proc
			if (expression.Method.Name == "Where")
				innermostWhereExpression = expression
			Visit(expression.Arguments[0])
			mreturn expression
		endmethod
	endclass

	internal class InnermostOrderByFinder extends ExpressionVisitor
    
		private innermostOrderByExpression, @MethodCallExpression
    
		public method GetInnermostOrderBy, @MethodCallExpression
			expression, @Expression 
			endparams
		proc
			Visit(expression)
			mreturn innermostOrderByExpression
		endmethod
    
		protected override method VisitMethodCall, @Expression
			expression, @MethodCallExpression 
			endparams
		proc
			if (expression.Method.Name == "OrderBy")
				innermostOrderByExpression = expression
			Visit(expression.Arguments[0])
			mreturn expression
		endmethod
	endclass

	internal class ExpressionTreeModifier extends ExpressionVisitor
    
		private original, @Expression
		private newExpression, @IQueryable
    
		internal method ExpressionTreeModifier
			original, @Expression
			newConstant, @IQueryable
			endparams
		proc
			this.original = original
			this.newExpression = newConstant
		endmethod
    
		protected override method VisitConstant, @Expression
			c, @ConstantExpression 
			endparams
		proc
			;;  Replace the constant QueryableTerraServerData arg with the queryable Place collection. 
			if (original == c) then
				mreturn Expression.Constant(newExpression)
			else
				mreturn c
		endmethod

		protected override method VisitMethodCall, @Expression
			m, @MethodCallExpression 
			endparams
		proc
			if (original == m) then
				mreturn Expression.Constant(newExpression)
			else
				mreturn m
		endmethod

		public method Eval, @Expression
			node, @Expression
		proc
			mreturn Visit(node)
		endmethod
	endclass
endnamespace
