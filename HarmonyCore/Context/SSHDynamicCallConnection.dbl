import System
import System.Collections.Generic
import System.Text
import Renci.SshNet
import Renci.SshNet.Common
import System.IO
import Newtonsoft.Json
import System.Diagnostics
import System.Threading.Tasks
import StreamJsonRpc

namespace Harmony.Core.Context

	public class SSHDynamicCallConnection implements IDynamicCallConnection
		private static NewLineBytes, [#]Byte, new byte[#] { 10, 13 }
		private mTargetConnection, @SshClient
		private mTargetShell, @ShellStream
		private mLaunchCommand, @string
		private mMakeReadyTask, @Lazy<Task<JsonRpc>>
		private mTargetOS, RemoteTargetOS
		public method SSHDynamicCallConnection
			targetOS, RemoteTargetOS
			startInfo, @ConnectionInfo
			command, @string
		proc
			mTargetOS = targetOS
			mLaunchCommand = command
			mTargetConnection = new SshClient(startInfo)
			mMakeReadyTask = new Lazy<Task<JsonRpc>>(MakeReadyInternal)
		endmethod
		
		public virtual method Recycle, @Task
			endparams
		proc
			mreturn Task.FromResult(true)
		endmethod
				
		public virtual method Disconnect, void
			endparams
		proc
			mTargetConnection.Disconnect()
		endmethod

		public virtual async method Call, @Task<[#]@ReturnParameterDefintion>
			name, @string
			args, [#]@ArgumentDataDefinition
		proc
			data jsonRpcConnection = await mMakeReadyTask.Value
			mreturn await jsonRpcConnection.InvokeAsync<[#]@ReturnParameterDefintion>(name, args)
		endmethod

		public async virtual method MakeReadyInternal, @Task<JsonRpc>
			endparams
		proc
			mTargetConnection.Connect()
			mTargetShell = mTargetConnection.CreateShellStream("vt220", 0, 0,0,0, 1024 * 64)
			data reader = new StreamReader(mTargetShell) 
			data writer = new StreamWriter(mTargetShell)
			data guidString, @string, Guid.NewGuid().ToString()
			data guidStrings = new HashSet<string>()
			data readLine, @string
			data foundMatch, boolean, false
			guidStrings.Add(guidString)

			while(String.IsNullOrWhiteSpace(readLine) || readLine != guidString)
			begin
				if(readLine == ^null || !foundMatch)
				begin
					if(mTargetOS == RemoteTargetOS.VMS) then
					begin
						await writer.WriteAsync('WRITE SYS$OUTPUT "' + guidString +  '"' + %char(13) + %char(10))
					end
					else
					begin
						await writer.WriteAsync('echo "' + guidString +  '"' + %char(13) + %char(10))
					end

					await writer.FlushAsync()
				end

				readLine = TrimControlChars(await reader.ReadLineAsync())
				while(String.IsNullOrWhiteSpace(readLine))
				begin
					readLine = TrimControlChars(await reader.ReadLineAsync())
				end

				data checkString, @string
				foundMatch = false
				foreach checkString in guidStrings
				begin
					if(readLine.Contains(checkString)) 
					begin
						foundMatch = true
						exitloop
					end
				end

				if(!foundMatch)
				begin
					guidString = Guid.NewGuid().ToString()
					guidStrings.Add(guidString)
				end
			end

			
			await writer.WriteAsync(mLaunchCommand + %char(13) + %char(10))
			await writer.FlushAsync()

			do
			begin
				readLine = TrimControlChars(await reader.ReadLineAsync())
			end
			until(readLine == "READY")
			
			mreturn JsonRpc.Attach(mTargetShell, ^null) 
		endmethod
	
		public method TrimControlChars, @string
			arg, @string
		proc
			if(arg == ^null)
				mreturn ^null

			data arrForm = arg.ToCharArray()
			data buffer = new StringBuilder(arg.Length)
			data ch, char
			foreach ch in arrForm
				if (!Char.IsControl(ch) && !Char.IsWhiteSpace(ch)) 
					buffer.Append(ch)
 
			mreturn buffer.ToString()
		endmethod



		public virtual method MakeReady, @Task
		proc
			mreturn mMakeReadyTask.Value
		endmethod

	endclass

endnamespace
