import System
import System.Collections.Generic
import System.Text
import Renci.SshNet
import Renci.SshNet.Common
import System.IO
import Newtonsoft.Json
import System.Diagnostics
import System.Threading.Tasks

namespace Harmony.Core.Context

	public class SSHDynamicCallConnection implements IDynamicCallConnection
		private static NewLineBytes, [#]Byte, new byte[#] { 10, 13 }
		private mTargetConnection, @SshClient
		private mTargetShell, @ShellStream
		private mProtocolInfo, @ProtocolMessage
        private mLaunchCommand, @string
        private mMakeReadyTask, @Lazy<Task>
		public method SSHDynamicCallConnection
			startInfo, @ConnectionInfo
			command, @string
		proc
			mLaunchCommand = command
            mTargetConnection = new SshClient(startInfo)
            mMakeReadyTask = new Lazy<Task>(MakeReadyInternal)
		endmethod

		public async virtual method ReadRaw, @Task<string>
			terminator, Char 
			endparams
        proc
            await mMakeReadyTask.Value
			data lengthBuffer = new byte[10]
			
			data offset, int, 0
			while(offset < 10)
				offset = mTargetShell.Read(lengthBuffer, offset, 10 - offset)
			try
			begin
				data expectedMessageLength = Convert.ToInt32(Encoding.ASCII.GetString(lengthBuffer))
				data messageBuffer = new byte[expectedMessageLength]
				offset = 0
                while(offset < expectedMessageLength)
					offset += mTargetShell.Read(messageBuffer, offset, expectedMessageLength - offset)
				mreturn Encoding.ASCII.GetString(messageBuffer)
			end
			catch(ex, @Exception)
			begin
				mreturn Encoding.ASCII.GetString(lengthBuffer) + mTargetShell.ReadLine()
			end
			endtry
		endmethod
		
		public virtual method Recycle, @Task
			endparams
		proc
			
		endmethod
				
		public virtual method Disconnect, void
			endparams
		proc
			mTargetConnection.Disconnect()
		endmethod
		
		class ProtocolMessage
			public readwrite property ProtocolSupported, boolean
		endclass


		public async virtual method MakeReadyInteral, @Task
			endparams
		proc
			data handshakeString = '{"ProtocolVersion":"1.0"}'
			mTargetConnection.Connect()
			mTargetShell = mTargetConnection.CreateShellStream("vt220", 0, 0,0,0, 1024 * 64)
			data guidString = Guid.NewGuid().ToString()
			data readLine = mTargetShell.Read()
			mTargetShell.WriteLine('WRITE SYS$OUTPUT "' + guidString +  '"')
			while((readLine = mTargetShell.ReadLine().Trim()) != guidString)
			begin
				if(readLine.EndsWith(">"))
				begin
					guidString = Guid.NewGuid().ToString()
					mTargetShell.WriteLine('WRITE SYS$OUTPUT "' + guidString +  '"')
				end

                Debug.Write(readLine)
				Debug.WriteLine(".")
			end
			mTargetShell.WriteLine(mLaunchCommand)
			
			while((readLine = mTargetShell.ReadLine().Trim()) != "READY")
			begin
				Debug.WriteLine(readLine)
			end
			mTargetShell.WriteLine(handshakeString.Length.ToString().PadLeft(10, '0'))
			data lengthStringEcho = mTargetShell.ReadLine()
			mTargetShell.WriteLine(handshakeString)
			data lengthBuffer = new byte[10]
			data offset, int, 0
			while(offset < 10)
				offset += mTargetShell.Read(lengthBuffer, offset, 10 - offset)
			data expectedMessageLengthString = Encoding.ASCII.GetString(lengthBuffer)
			data expectedMessageLength = Convert.ToInt32(expectedMessageLengthString)
			data messageBuffer = new byte[expectedMessageLength]
            offset = 0
            
            while(offset < expectedMessageLength)
				offset += mTargetShell.Read(messageBuffer, offset, expectedMessageLength - offset)
			data messageString = Encoding.ASCII.GetString(messageBuffer)
			data deserializedMessage = JsonConvert.DeserializeObject<ProtocolMessage>(messageString)
			if(!deserializedMessage.ProtocolSupported)
				throw new Exception("Protocol not supported")

		endmethod
		
		public virtual method WriteRaw, void
			rawData, [#]byte
			endparams
		proc
			data paddedLengthString = rawData.Length.ToString().PadLeft(10, '0')
			mTargetShell.WriteLine(paddedLengthString)
			data response = mTargetShell.ReadLine()
			mTargetShell.Write(rawData, 0, rawData.Length)
			mTargetShell.WriteLine("")
			mTargetShell.Flush()
			
		endmethod
	
        public virtual method MakeReady, @Task
        proc
            mreturn mMakeReadyTask.Value
        endmethod

	endclass

endnamespace
