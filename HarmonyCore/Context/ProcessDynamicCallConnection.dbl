import System
import System.Collections.Generic
import System.Text
import System.Diagnostics
import Newtonsoft.Json
import Newtonsoft.Json.Linq
import System.Threading.Tasks
import StreamJsonRpc


namespace Harmony.Core.Context

	public class ProcessDynamicCallConnection implements IDynamicCallConnection
		private static NewLineBytes, [#]Byte, new byte[#] { 10, 13 }
		private mTargetProcess, @Process
		private mMakeReadyTask, @Lazy<Task<JsonRpc>>
		public method ProcessDynamicCallConnection
			startInfo, @ProcessStartInfo
		proc
			mTargetProcess = new Process()
			mTargetProcess.StartInfo = startInfo
            mMakeReadyTask = new Lazy<Task<JsonRpc>>(MakeReadyInternal)
		endmethod

		public virtual method Recycle, @Task
			endparams
		proc
			mreturn Task.FromResult(true)
		endmethod
				
		public virtual method Disconnect, void
			endparams
		proc
			mTargetProcess.Kill()
		endmethod
		
		class ProtocolMessage
			public readwrite property ProtocolSupported, boolean
		endclass

		public virtual async method Call, @Task<[#]@ReturnParameterDefintion>
			name, @string
			args, [#]@ArgumentDataDefinition
		proc
			data jsonRpcConnection = await mMakeReadyTask.Value
			mreturn await jsonRpcConnection.InvokeAsync<[#]@ReturnParameterDefintion>(name, args)
		endmethod

		private async method MakeReadyInternal, @Task<JsonRpc>
			endparams
		proc
			data readLine, @string
			mTargetProcess.Start()
			mTargetProcess.StartInfo.StandardOutputEncoding = ASCIIEncoding.ASCII
			while((readLine = mTargetProcess.StandardOutput.ReadLine()) != "READY")
			begin
				Debug.WriteLine("Not Ready")
			end
			
			mreturn JsonRpc.Attach(mTargetProcess.StandardInput.BaseStream, mTargetProcess.StandardOutput.BaseStream, ^null) 
		endmethod
	
        public virtual method MakeReady, @Task
        proc
            mreturn mMakeReadyTask.Value
        endmethod


	endclass

endnamespace
