import System
import System.Collections.Generic
import System.Text
import Newtonsoft.Json
import Harmony.Core
import Newtonsoft.Json.Linq
import System.Linq
import System.Reflection
import System.Threading.Tasks

namespace Harmony.Core.Context

	public abstract class DynamicCallProvider implements IDynamicCallProvider
		
		class CallFrame
			public readwrite property Name, @string
			public readwrite property Arguments, [#]@ArgumentDataDefinition
		endclass


		class MethodCallResponseValue
			public readwrite property ReturnParameters, @List<ReturnParameterDefintion>
		endclass

		class MethodCallResponse
			public readwrite property IsError, boolean
			public readwrite property Exception, @string
			public readwrite property Result, @MethodCallResponseValue
		endclass

		internal static CastMethodInfo, @MethodInfo

		static method DynamicCallProvider
		proc
			CastMethodInfo = ^typeof(Enumerable).GetMethod("Cast")
        endmethod


		protected connection, @IDynamicCallConnection
		public readonly property IsolationLevel, ContextIsolationLevel
		protected method DynamicCallProvider
			connection, @IDynamicCallConnection
		proc
			this.connection = connection
		endmethod

		public virtual method CallMethod, @Task<Tuple<Object, [#]@Object>>
			name, @string
			{ParamArray}
			args, [#]@object 
			endparams
		proc
			data hoist = new CallHoist<Object>() { CallProvider = this }
			mreturn hoist.CallMethod(name, args)

;            data argsTemp, [#]@Object, args
;			data arguments, [#]@ArgumentDataDefinition, new ArgumentDataDefinition[args.Length + 1]
;			data i, int, 0
;			for i from 1 thru args.Length
;			begin
;				data arg, @ArgumentDataDefinition, PreSerializeArgument(args[i])
;				arguments[i + 1] = arg
;			end
;
;			arguments[1] = new ArgumentDataDefinition() { PassedValue = ^null, ReturnedValue = true }
;
;			data returnType = ^typeof(T)
;            if(returnType.IsPrimitive) then
;				arguments[1].DataType = FieldDataType.IntegerField
;			else if(returnType == ^typeof(string)) then
;				arguments[1].DataType = FieldDataType.AlphaField
;			else
;				arguments[1].DataType = FieldDataType.DataObjectField
;
;			arguments = await CallMethodImplementation(name, arguments)
;
;			for i from 1 thru args.Length
;			begin
;				if(arguments[i + 1].ReturnedValue != ^null && arguments[i + 1].ReturnedValue.Value)
;				begin
;					data argValue = arguments[i + 1]
;					if(argValue.PassedValue .is. JToken) then
;                    begin
;						data targetToken = ((@JToken)argValue.PassedValue)
;						argsTemp[i] = targetToken.ToObject(argsTemp[i].GetType())
;					end
;					else
;					begin
;						if(argValue.DataType == FieldDataType.DataObjectField) then
;						begin
;							argsTemp[i] = argValue.PassedValue
;						end
;						else if(argValue.DataType == FieldDataType.DataObjectCollectionField) then
;						begin
;							data tempCollection = (@IEnumerable<DataObjectBase>)argValue.PassedValue
;                            ;;TODO replace this with a generic element getter
;							data argType = args[i].GetType().GetGenericArguments()[1]
;							argsTemp[i] = CastMethodInfo.MakeGenericMethod(new Type[#] { argType }).Invoke(^null, new object[#] { tempCollection })
;						end
;						else
;						begin
;							argsTemp[i] = Convert.ChangeType(argValue.PassedValue, argsTemp[i].GetType())
;						end
;
;					end
;				end
;			end
;
;			if(arguments[1].PassedValue .is. JToken) then
;			begin
;				data retValue = ((@JToken)arguments[1].PassedValue)
;				mreturn Tuple.Create(retValue.Value<T>(), argsTemp)
;			end
;			else
;			begin
;				mreturn Tuple.Create((T)Convert.ChangeType(arguments[1].PassedValue,^typeof(T)), argsTemp)
;			end
		endmethod
		
        public async virtual method CallMethodV, @Task<[#]@object>
			name, @string
			{ParamArray}
			args, [#]@object 
			endparams
		proc
			data argsTemp = args
			data arguments, [#]@ArgumentDataDefinition, new ArgumentDataDefinition[args.Length]
			data i, int, 0
			for i from 1 thru args.Length
			begin
				data arg, @ArgumentDataDefinition, PreSerializeArgument(args[i])
				arguments[i] = arg
			end

			;;TODO check identities of objects to potentially write back
			arguments = await CallMethodImplementation(name, arguments)

			for i from 1 thru args.Length
			begin
				if(arguments[i].ReturnedValue != ^null && arguments[i].ReturnedValue.Value)
				    argsTemp[i] = arguments[i].PassedValue
			end

			mreturn argsTemp
		endmethod

		private method PreSerializeIEnumerable, @object
			argValue, @System.Collections.IEnumerable
		proc
			data result = new List<object>()
			data objValue, @Object
			foreach objValue in argValue
			begin
				result.Add(PreSerializeArgument(objValue).PassedValue)
			end
			mreturn result
		endmethod

		;;remove this overload after the async peverify issue is taken care of
		internal virtual method PreSerializeArgumentsInternal, @ArgumentDataDefinition
			argValue, @Object
		proc
			mreturn PreSerializeArgument(argValue)
		endmethod


		protected virtual method PreSerializeArgument, @ArgumentDataDefinition
			argValue, @Object
		proc
			data argDef = new ArgumentDataDefinition()
				
			if(argValue .is. DataObjectBase) then
			begin
				data doValue = (@DataObjectBase)argValue
				argDef.DataType = FieldDataType.DataObjectField
				;;we might want to convert to base64 here for the value and grfa
				lambda preSerializeDataObject(alphaData, grfaData)
				begin
					data dict = new Dictionary<string, object>()
					dict.Add("Type", doValue.Metadata.RPSStructureName)
					dict.Add("Value", Convert.ToBase64String(([#]byte)alphaData))
					dict.Add("GRFA", Convert.ToBase64String(([#]byte)grfaData))
					argDef.PassedValue = dict
				end
				doValue.InternalSynergyRecord(preSerializeDataObject)
			end
			else if(argValue .is. @String) then
			begin
				argDef.DataType = FieldDataType.AlphaField
				argDef.PassedValue = argValue
			end
			else if(argValue .is. System.Collections.IEnumerable) then
			begin
				argDef.DataType = FieldDataType.DataObjectCollectionField
				argDef.PassedValue = PreSerializeIEnumerable((@System.Collections.IEnumerable)argValue)
			end
			else if(argValue .is. @a) then
			begin
				argDef.DataType = FieldDataType.AlphaField
				;;we might want to convert to base64 here for the value
				argDef.PassedValue = argValue
			end
			else if(argValue .is. @d) then
			begin
				argDef.DataType = FieldDataType.DecimalField
				argDef.PassedValue = argValue.ToString()
			end
			else if(argValue .is. @id) then
			begin
				argDef.DataType = FieldDataType.ImpliedDecimal
				argDef.PassedValue = argValue.ToString()
			end
			else if(argValue .is. @i) then
			begin
				argDef.DataType = FieldDataType.IntegerField
				argDef.PassedValue = argValue
			end
			else if(argValue .is. double || argValue .is. float || argValue .is. decimal) then
			begin
				argDef.DataType = FieldDataType.ImpliedDecimal
				argDef.PassedValue = Convert.ToString(argValue)
				argDef.DecimalPrecision = 28
				argDef.ElementSize = 56
			end
			else if(argValue .is. byte || argValue .is. sbyte || argValue .is. char || argValue .is. short || argValue .is. ushort || argValue .is. int || argValue .is. uint || argValue .is. long || argValue .is. ulong) then
			begin
				argDef.DataType = FieldDataType.IntegerField
				argDef.PassedValue = argValue
			end
			else
				throw new NotImplementedException()

			mreturn argDef
		endmethod

		protected static SerializerSettings, @JsonSerializerSettings, new JsonSerializerSettings() { NullValueHandling=NullValueHandling.Ignore }
		protected async method CallMethodImplementation, @Task<[#]@ArgumentDataDefinition>
			name, @string
			args, [#]@ArgumentDataDefinition
		proc
			data result, [#]@ReturnParameterDefintion, await this.connection.Call(name, args)
			data writableArgs = args
			if(result != ^null)
			begin
				data retArg, @ReturnParameterDefintion
				foreach retArg in result
				begin
					writableArgs[retArg.Position + 1].ReturnedValue = true
					writableArgs[retArg.Position + 1].PassedValue = retArg.Value.PassedValue
				end
			end
			mreturn writableArgs
		endmethod
		;;remove this overload after the async peverify issue is taken care of
		internal method CallMethodImplementationInternal, @Task<[#]@ArgumentDataDefinition>
			name, @string
			args, [#]@ArgumentDataDefinition
		proc
			mreturn CallMethodImplementation(name, args)
		endmethod

	endclass

	;;TODO: this should go back to the method version once the peverify issue is taken care of in the compiler
	internal class CallHoist<T>
		public readwrite property CallProvider, @DynamicCallProvider

		public async method CallMethod, @Task<Tuple<T, [#]@Object>>
			name, @string
			args, [#]@object 
		proc
			data argsTemp, [#]@Object, args
			data arguments, [#]@ArgumentDataDefinition, new ArgumentDataDefinition[args.Length + 1]
			data i, int, 0
			for i from 1 thru args.Length
			begin
				data arg, @ArgumentDataDefinition, CallProvider.PreSerializeArgumentsInternal(args[i])
				arguments[i + 1] = arg
			end

			arguments[1] = new ArgumentDataDefinition() { PassedValue = ^null, ReturnedValue = true }

			data returnType = ^typeof(T)
			if(returnType.IsPrimitive) then
				arguments[1].DataType = FieldDataType.IntegerField
			else if(returnType == ^typeof(string)) then
				arguments[1].DataType = FieldDataType.AlphaField
			else
				arguments[1].DataType = FieldDataType.DataObjectField

			arguments = await CallProvider.CallMethodImplementationInternal(name, arguments)

			for i from 1 thru args.Length
			begin
				if(arguments[i + 1].ReturnedValue != ^null && arguments[i + 1].ReturnedValue.Value)
				begin
					data argValue = arguments[i + 1]
					if(argValue.PassedValue .is. JToken) then
					begin
						data targetToken = ((@JToken)argValue.PassedValue)
						argsTemp[i] = targetToken.ToObject(argsTemp[i].GetType())
					end
					else
					begin
						if(argValue.DataType == FieldDataType.DataObjectField) then
						begin
							argsTemp[i] = argValue.PassedValue
						end
						else if(argValue.DataType == FieldDataType.DataObjectCollectionField) then
						begin
							data tempCollection = (@IEnumerable<DataObjectBase>)argValue.PassedValue
							;;TODO replace this with a generic element getter
							data argType = args[i].GetType().GetGenericArguments()[1]
							argsTemp[i] = DynamicCallProvider.CastMethodInfo.MakeGenericMethod(new Type[#] { argType }).Invoke(^null, new object[#] { tempCollection })
						end
						else
						begin
							argsTemp[i] = Convert.ChangeType(argValue.PassedValue, argsTemp[i].GetType())
						end

					end
				end
			end

			if(arguments[1].PassedValue .is. JToken) then
			begin
				data retValue = ((@JToken)arguments[1].PassedValue)
				mreturn Tuple.Create(retValue.Value<T>(), argsTemp)
			end
			else
			begin
				mreturn Tuple.Create((T)Convert.ChangeType(arguments[1].PassedValue,^typeof(T)), argsTemp)
			end
		endmethod

	endclass

endnamespace
