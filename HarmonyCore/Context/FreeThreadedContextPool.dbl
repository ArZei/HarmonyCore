import System.Collections.Concurrent
import System
import System.Collections.Generic
import System.Text
import Microsoft.CodeAnalysis.PooledObjects
import System.Threading.Tasks
import Microsoft.Extensions.DependencyInjection
import Harmony.Core.Interface
import Harmony.Core.Utility

namespace Harmony.Core.Context

	public class FreeThreadedContextPool<T(IContextBase, class)> extends ContextFactory<T> implements IContextPool<T>

		public virtual async method RealizeMinimumPoolSize, @Task
			provider, @IServiceProvider
			endparams
		proc
			while(mContextPool.Count < mMinSize)
			begin
				data madeContext, @IContextBase, mContextPool.Allocate(provider)
				if(madeContext .is. IPooledContextBase)
				begin
					await ((@IPooledContextBase)madeContext).EnsureReady()
				end

				mContextPool.Free(madeContext)
			end
		endmethod

		public virtual method TrimPool, @Task
			targetSize, int 
			endparams
		proc
			while(mContextPool.Count > targetSize)
			begin
				try
				begin
					;;this shouldnt actually perform an allocation
					data context = mContextPool.Allocate(^null)
					if(context .is. IDisposable)
						((@IDisposable)context).Dispose()
				end
				catch (ex, @Exception)
				begin
					DebugLogSession.Logging.LogException(ex, this.GetType().FullName)
				end
				endtry

			end
			mreturn Task.FromResult(true)
		endmethod

		private mMinSize, int
		private mSessionLookup, @ConcurrentDictionary<string, T>
		private mContextPool, @ObjectPool<T>
		public method FreeThreadedContextPool
			min, int
		proc
			mSessionLookup = new ConcurrentDictionary<string, T>()
			mContextPool = new ObjectPool<T>(lambda(provider) { SlowMakeContext(provider) }, min)
			DebugLogSession.Logging.LogInfo("FreeThreadedContextPool<{0}>::ctor with a minimum size of {1}", ^typeof(T).FullName, min)
		endmethod

		public override method MakeContextAsync, @Task<T>
			sessionId, @string 
			provider, @IServiceProvider
			endparams
		proc
			mreturn Task.FromResult(MakeContext(sessionId, provider))
		endmethod
		
		public override method MakeContext, T
			sessionId, @string
			provider, @IServiceProvider
			endparams
		proc
			data result = mContextPool.Allocate(provider)
			if(result .is. IPooledContextBase)
			begin
				((@IPooledContextBase)result).InitServices(provider)
			end
			mreturn result
		endmethod

		protected virtual method SlowMakeContext, T
			provider, @IServiceProvider
		proc
			data logging = provider.GetService<IDebugLogging>() ?? DebugLogSession.Logging
			logging.LogInfo("FreeThreadedContextPool<{0}>::SlowMakeContext", ^typeof(T).FullName)
			mreturn ActivatorUtilities.CreateInstance<T>(provider)
		endmethod

		public override method ReturnContext, void
			context, T
		proc
			mContextPool.Free(context)
		endmethod
	endclass

endnamespace
