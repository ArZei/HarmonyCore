import Harmony.Core
import System.Collections

namespace TraditionalBridge
	abstract class RoutineDispatcher
		protected loggingChannel, i4

		public method RoutineDispatcher
		proc
			loggingChannel = 0
			open(loggingChannel, O, "c:\wrk\dispatcher.log")
		
		endmethod

		protected abstract method DeserializeObject, @DataObjectBase
			obj, @Json.JsonObject
		proc
		endmethod

		protected abstract method DeserializeObjectCollection, @ArrayList
			obj, @Json.JsonObject
		proc
		endmethod

		protected method UnwrapObjectCollection, void
			memoryHandle, i4
			collection, @ArrayList
		proc
			
		endmethod

		protected method UnwrapObjectCollection, void
			inout buffer, a
			elementSize, i
			inout bufferPosition, i
			collection, @Json.JsonArray
			record
				element, @Json.JsonValue
		proc
			foreach element in collection.arrayValues
			begin
				if(element .is. Json.JsonObject) then
				begin
					data stringValue = ((@Json.JsonText)((@Json.JsonObject)element).GetProperty("Value")).Value
					buffer(bufferPosition:elementSize) = stringValue
				end
				else if(element .is. Json.JsonText) then
				begin
					buffer(bufferPosition:elementSize) = ((@Json.JsonText)element).Value
				end
				else if(element .is. Json.JsonNumber) then
				begin

				end
				else if(element .is. Json.JsonInt) then
				begin

				end
				else if(element .is. Json.JsonBoolean) then
				begin
				end
				else if(element .is. Json.JsonArray)
				begin

				end
				bufferPosition += elementSize
			end

		endmethod

		protected abstract method SerializeObject, void
			obj, @DataObjectBase
			serializer, @Json.ChannelSerializer
		proc
		endmethod

		protected abstract method SerializeObjectCollection, void
			obj, @ArrayList
			serializer, @Json.ChannelSerializer
		proc
		endmethod

		protected method GetText, a
			value, @Json.JsonObject
			record
				valueText, @Json.JsonText
		proc
			valueText = (@Json.JsonText)value.GetProperty("PassedValue")
			mreturn valueText.Value
		endmethod

		protected method GetInt, i
			value, @Json.JsonObject
			record
				valueInt, @Json.JsonInt
		proc
			valueInt = (@Json.JsonInt)value.GetProperty("PassedValue")
			mreturn valueInt.Value
		endmethod

		protected method GetDecimal, d
			value, @Json.JsonObject
			record
				passedValue, @Json.JsonValue
				valueInt, @Json.JsonInt
				valuestring, @Json.JsonText
				tempD, d28
		proc
			passedValue = value.GetProperty("PassedValue")
			if(passedValue.JsonType == Json.JSON_TYPE.INT_VAL ) then
			begin
				valueInt = (@Json.JsonInt)passedValue
				tempD = valueInt.Value
				mreturn tempD
			end
			else
			begin
				valuestring = (@Json.JsonText)passedValue
				mreturn ^d((a)valuestring.Value)
			end
		endmethod

		protected method SerializeObject, void
			obj, @object
			serializer, @Json.ChannelSerializer
		proc
			if(obj .is. @DataObjectBase) then
				SerializeObject((@DataObjectBase)obj, serializer)
			else if(obj .is. @ArrayList) then
				SerializeObjectCollection((@ArrayList)obj, serializer)
			else if(obj .is. @a || obj .is. @d || obj .is. @id || obj .is. @string) then
				serializer.String(obj.ToString())
			else if(obj .is. @i) then
				serializer.Integer((i)obj)
			else
				throw new Exception("Attempted to serialize an unknown object type")
		endmethod

		protected method DeserializeObject, @object
			obj, @Json.JsonObject
			out dataType, FieldDataType
			record
				dataTypeInt, @Json.JsonInt
		proc
			dataTypeInt = ((@Json.JsonInt)obj.GetProperty("DataType"))
			dataType = (FieldDataType)dataTypeInt.Value
			if(dataType == FieldDataType.DataObjectField) then
			begin
				mreturn DeserializeObject(obj)
			end
			else if(dataType == FieldDataType.DataObjectCollectionField) then
			begin
				mreturn DeserializeObjectCollection(obj)
			end
			else if(dataType == FieldDataType.AlphaField) then
			begin
				data textObject, @Json.JsonText, ((@Json.JsonText)obj.GetProperty("PassedValue"))
				mreturn textObject.Value
			end
			else if(dataType == FieldDataType.DecimalField) then
			begin
				mreturn ((@Json.JsonText)obj.GetProperty("PassedValue")).Value
			end
			else if(dataType == FieldDataType.ImpliedDecimal) then
			begin
				mreturn ((@Json.JsonText)obj.GetProperty("PassedValue")).Value
			end
			else if(dataType == FieldDataType.IntegerField)
			begin
				data intValue, i4, ((@Json.JsonInt)obj.GetProperty("PassedValue")).Value
				mreturn (@object)intValue
			end
		endmethod

		protected abstract method DispatchRoutineStub, void
			name, @string
			callFrame, @Json.JsonObject
			serializer, @Json.ChannelSerializer
		proc
		endmethod

		protected abstract method IsStubbedRoutine, boolean
			name, @string
		proc
		endmethod

		private method ReadCallBlock, boolean
			ttChannel, i
			frameHeader, i4
			record
				frameDataHandle, D_HANDLE
				jsonReader, @Json.Json
				parsedJson, @Json.JsonValue
		proc
			jsonReader = new Json.Json()
			frameDataHandle = %mem_proc(DM_ALLOC, frameHeader)
			gets(ttChannel, ^m(frameDataHandle))
			writes(loggingChannel, "reading callblock: ")
			writes(loggingChannel, ^m(frameDataHandle))
			parsedJson = jsonReader.ParseJson(^m(frameDataHandle))
			if(parsedJson .is. @Json.JsonObject) then
			begin
				data result, boolean, ProcessCallBlock((@Json.JsonObject)parsedJson, ttChannel)
				mreturn result
			end
			else
			begin
				data serializer = new Json.ChannelSerializer(ttChannel)
				serializer.MapOpen()
				serializer.String("IsError")
				serializer.Bool(true)
				serializer.String("Exception")
				serializer.String("failed to parse json request")
				serializer.MapClose()
				mreturn true
			end
		endmethod


		public method Dispatch, void
			ttChannel, i
			record aData
				frameHeader, d10
			record
				running, boolean
		proc
			;;read 10 bytes of data from input when its available
			;;read count of bytes from input (in chunks ideally) 
			;;look for the target routine name
			;;build rcb block for the call
			;;deserialize arguments based on the types in json
			;;make the call
			;;trap any exceptions
			running = true
			while(running)
			begin
				gets(ttChannel, aData, wait:-1)
				puts(ttChannel, aData + %char(13) + %char(10))
				running = ReadCallBlock(ttChannel, (int)frameHeader)
			end
			writes(ttChannel, "Shutting down due to running == false")
		endmethod

		public method ProcessCallBlock, boolean
			jsonData, @Json.JsonObject
			responseChannel, i4
			record
				name, @string
				argArray, @Json.JsonArray
				serializer, @Json.ChannelSerializer
		proc
			;;we've been asked to shutdown so return false and let the outer loop take care of it
			if(jsonData.HasProperty("IsShutdownRequest") && ((@Json.JsonBoolean)jsonData.GetProperty("IsShutdownRequest")).Value)
			begin
				writes(responseChannel, "Shutting down due to request")
				mreturn false
			end


			serializer = new Json.ChannelSerializer(responseChannel)

			try
			begin
				;;we've been asked if we're alive
				if(jsonData.HasProperty("IsPingRequest") && ((@Json.JsonBoolean)jsonData.GetProperty("IsPingRequest")).Value) then
				begin
					serializer.MapOpen()
					serializer.String("IsAlive")
					serializer.Bool(true)
					serializer.MapClose()
					mreturn true
				end
				else if(jsonData.HasProperty("ProtocolVersion") && ((@Json.JsonText)jsonData.GetProperty("ProtocolVersion")).Value =="1.0")
				begin
					serializer.MapOpen()
					serializer.String("ProtocolSupported")
					serializer.Bool(true)
					serializer.MapClose()
					mreturn true
				end

				name = ((@Json.JsonText)jsonData.GetProperty("Name")).Value

				if(IsStubbedRoutine(name)) then
				begin
					DispatchRoutineStub(name, jsonData, serializer)
					mreturn true
				end
				else
				begin
					data arg, @Json.JsonObject
					data argArray, @ArrayList, new ArrayList()
					data argValueArray, [#]@Object
					data rcbid, i4
					data ii, i4, 0
					if(jsonData.HasProperty("Arguments"))
					begin
						data arg, @Json.JsonObject
						data ii = 0
						argArray = ((@Json.JsonArray)jsonData.GetProperty("Arguments")).arrayValues
					end
					argValueArray = new object[argArray.Count]
					rcbid = %rcb_create(argArray.Count) 
					xcall rcb_setfnc(rcbid, name)
					foreach arg in argArray as @Json.JsonObject
					begin
						data argType, FieldDataType
						data argLength, i4, 0
						data argPrecision, i4, 0
						incr ii
						;;the arguments need somewhere to live while we're building up the call so put them into this array
						argValueArray[ii] = DeserializeObject(arg, argType)
						if(argType != FieldDataType.DataObjectField && argType != FieldDataType.DataObjectCollectionField) then
						begin
							if(jsonData.HasProperty("DecimalPrecision"))
								argPrecision = ((@Json.JsonInt)jsonData.GetProperty("DecimalPrecision")).Value

							argLength = ((@Json.JsonInt)jsonData.GetProperty("ElementSize")).Value

							xcall rcb_setarg(rcbid, (n)argValueArray[ii], ii, (i)argType, argLength, argPrecision)
						end
						else
							xcall rcb_setarg(rcbid, argValueArray[ii], ii)
					end
					xcall rcb_call(rcbid) 
					ii = 0

					serializer.MapOpen()
					serializer.String("IsError")
					serializer.Bool(false)
					serializer.String("Result")
					serializer.MapOpen()
					serializer.String("ReturnParameters")
					serializer.ArrayOpen()

					foreach arg in argArray as @Json.JsonObject
					begin
						incr ii
						if(arg.HasProperty("ReturnParameter") && ((@Json.JsonBoolean)arg.GetProperty("ReturnParameter")).Value)
						begin
							serializer.MapOpen()
							serializer.String("Position")
							serializer.Integer(ii)
							serializer.String("Value")
							SerializeObject(argValueArray[ii], serializer)
							serializer.MapClose()
						end

					end
					serializer.ArrayClose()
					serializer.MapClose()
					serializer.MapClose()
				end
			end
			catch(ex, @Exception)
			begin
				;;TODO maybe this should be a specific type, we might need to do additional processing for certain exception types here
				serializer.MapOpen()
				serializer.String("IsError")
				serializer.Bool(true)
				serializer.String("Exception")
				serializer.String(ex.ToString())
				serializer.MapClose()
				mreturn false
			end
			endtry

			writes(responseChannel, "unhandled message")
			mreturn false
		endmethod

	endclass

endnamespace