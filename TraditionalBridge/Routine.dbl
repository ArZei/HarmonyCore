import System.Collections
import System.Collections

namespace Harmony.TraditionalBridge
	abstract class RoutineDispatcher
		protected loggingChannel, i4
		protected mDispatchStubs, @StringDictionary
		public method RoutineDispatcher
		proc
			mDispatchStubs = new StringDictionary()
			loggingChannel = 0
			open(loggingChannel, O, "dispatcher.log")
		endmethod

		public virtual method DeserializeObject, @DataObjectBase
			obj, @Json.JsonObject
			targetType, @DataObjectMetadataBase
			record
				passedValue, @Json.JsonObject
				objectMetadata, @DataObjectMetadataBase
				objectType, @Json.JsonText
		proc
			passedValue = (@Json.JsonObject)obj.GetProperty("PassedValue")
			objectMetadata = targetType
			if(objectMetadata == ^null)
			begin
				objectType = (@Json.JsonText)passedValue.GetProperty("Type")
				objectMetadata = DataObjectMetadataBase.LookupType(objectType.Value)
			end
			mreturn objectMetadata.Deserialize(passedValue)
		endmethod

		;;Protocol note: this is another place where we need to decide how much we can ommit from the contents of collections
		;;this is currently assuming we are only working with DataObjectBase
		public virtual method DeserializeObjectCollection, @ArrayList
			obj, @Json.JsonObject
			record
				passedValue, @Json.JsonArray
				elementValue, @Json.JsonObject
				objectMetadata, @DataObjectMetadataBase
				objectType, @Json.JsonText
				result, @ArrayList
		proc
			result = new ArrayList()
			passedValue = (@Json.JsonArray)obj.GetProperty("PassedValue")
			foreach elementValue in passedValue.arrayValues
			begin
				;;TODO might be able to skip the lookup if the typename hasnt changed
				objectType = (@Json.JsonText)elementValue.GetProperty("Type")
				objectMetadata = DataObjectMetadataBase.LookupType(objectType.Value)
				result.Add(objectMetadata.Deserialize(elementValue))
			end
			mreturn result
		endmethod

		public method UnwrapObjectCollection, void
			memoryHandle, i4
			collection, @ArrayList
		proc
			
		endmethod

		;;this needs to take an expected type parameter of some kind so we can do basic conversions int -> decimal vs int -> int
		public method UnwrapObjectCollection, void
			inout buffer, a
			elementInfo, @ArgumentDataDefinition
			inout bufferPosition, i
			collection, @Json.JsonArray
			record
				element, @Json.JsonValue
		proc
			foreach element in collection.arrayValues
			begin
				if(element .is. Json.JsonObject) then
				begin
					data stringValue = ((@Json.JsonText)((@Json.JsonObject)element).GetProperty("Value")).Value
					buffer(bufferPosition:elementInfo.ElementSize) = stringValue
				end
				else if(element .is. Json.JsonText) then
				begin
					buffer(bufferPosition:elementInfo.ElementSize) = ((@Json.JsonText)element).Value
				end
				else if(element .is. Json.JsonNumber) then
				begin
					buffer(bufferPosition:elementInfo.ElementSize) = ((@Json.JsonNumber)element).Value
				end
				else if(element .is. Json.JsonInt) then
				begin
					if(elementInfo.DataType == FieldDataType.IntegerField) then
						buffer(bufferPosition:elementInfo.ElementSize) = ((@Json.JsonNumber)element).Value
					else
						buffer(bufferPosition:elementInfo.ElementSize) = %string(((@Json.JsonNumber)element).Value)
				end
				else if(element .is. Json.JsonBoolean) then
				begin
				end
				else if(element .is. Json.JsonArray)
				begin

				end
				bufferPosition += elementInfo.ElementSize
			end

		endmethod

		public method GetArgumentDataDefForCollection, @ArgumentDataDefinition
			argument, @Json.JsonObject
			record
				result, @ArgumentDataDefinition
				dataType, i4
		proc

			argument.TryGetProperty("DecimalPrecision", result.DecimalPrecision)
			argument.TryGetProperty("ElementSize", result.ElementSize)
			if(argument.TryGetProperty("DataType", dataType))
				result.DataType = (FieldDataType)dataType

			argument.TryGetBoolProperty("ReturnedValue", result.ReturnedValue)
			mreturn result
		endmethod

		;;this needs to take an expected type parameter of some kind so we can do basic conversions int -> decimal vs int -> int
		public method UnwrapObjectCollection, void
			elementInfo, @ArgumentDataDefinition
			collection, @Json.JsonArray
			targetArrayList, @ArrayList
			record
				element, @Json.JsonValue
		proc
			foreach element in collection.arrayValues
			begin
				if(element .is. Json.JsonObject) then
				begin
					data stringValue = ((@Json.JsonText)((@Json.JsonObject)element).GetProperty("Value")).Value
					targetArrayList.Add((@a)(a)stringValue)
				end
				else if(element .is. Json.JsonText) then
				begin
					;;TODO this needs to handle the arg type, could be d, id, a
					targetArrayList.Add((@a)(a)((@Json.JsonText)element).Value)
				end
				else if(element .is. Json.JsonNumber) then
				begin
					targetArrayList.Add((@id)((@Json.JsonNumber)element).Value)
				end
				else if(element .is. Json.JsonInt) then
				begin
					;;TODO this needs to handle the arg type, could be i, d, id
					targetArrayList.Add((@i)((@Json.JsonInt)element).Value)
				end
				else if(element .is. Json.JsonBoolean) then
				begin
					targetArrayList.Add((@boolean)((@Json.JsonBoolean)element).Value)
				end
				else if(element .is. Json.JsonArray)
				begin

				end
			end

		endmethod

		public virtual method SerializeObject, void
			obj, @DataObjectBase
			serializer, @Json.ChannelSerializer
		proc
			obj.Serialize(serializer)
		endmethod

		;;Protocol note: its not entirely decided how explicit we need to be about types for things
		;;most things in synergy dont jump from one primative type to another
		;;its possible for this to happen with an arraylist but this might be an acceptable tradoff for the significant protocol efficiancy gains
		;;in only specifying the element type once
		public virtual method SerializeObjectCollection, void
			obj, @ArrayList
			serializer, @Json.ChannelSerializer
			record
				doElement, @DataObjectBase
				primativeElement, @object
		proc
			;;determine the collection type from the first element type then serialize assuming we dont switch between primatives and objects
			serializer.ArrayOpen()
			if(obj.Count > 0)
			begin
				if(obj[0] .is. @DataObjectBase) then
				begin
					foreach doElement in obj
					begin
						doElement.Serialize(serializer)
					end
				end
				else
				begin
					;;this should encode something like this
					;;serializer.String("ElementSize")
					;;serializer.Int(^size(unboxedElement))
					;;get the unboxed type and put that in as serializer.String("ElementType")
					throw new Exception("primative arrays not yet supported")
				end

			end
			serializer.ArrayClose()
		endmethod

		public method GetText, a
			value, @Json.JsonObject
			record
				valueText, @Json.JsonText
		proc
			valueText = (@Json.JsonText)value.GetProperty("PassedValue")
			mreturn valueText.Value
		endmethod

		public method GetInt, i
			value, @Json.JsonObject
			record
				valueInt, @Json.JsonInt
		proc
			valueInt = (@Json.JsonInt)value.GetProperty("PassedValue")
			mreturn valueInt.Value
		endmethod

		public method GetDecimal, d
			value, @Json.JsonObject
			record
				passedValue, @Json.JsonValue
				valueInt, @Json.JsonInt
				valuestring, @Json.JsonText
				tempD, d28
		proc
			passedValue = value.GetProperty("PassedValue")
			if(passedValue.JsonType == Json.JSON_TYPE.INT_VAL ) then
			begin
				valueInt = (@Json.JsonInt)passedValue
				tempD = valueInt.Value
				mreturn tempD
			end
			else
			begin
				valuestring = (@Json.JsonText)passedValue
				mreturn ^d((a)valuestring.Value)
			end
		endmethod

		public method GetImplied, d.
			value, @Json.JsonObject
			record
				passedValue, @Json.JsonValue
				valueInt, @Json.JsonInt
				precisionValue, @Json.JsonValue
				precisionInt, @Json.JsonInt
				valuestring, @Json.JsonText
				tempD, d56.28
		proc
			passedValue = value.GetProperty("PassedValue")

			precisionValue = value.GetProperty("DecimalPrecision")
			precisionInt = (@Json.JsonInt)precisionValue

			if(passedValue.JsonType == Json.JSON_TYPE.INT_VAL ) then
			begin
				valueInt = (@Json.JsonInt)passedValue
				tempD = ^d(%string(valueInt.Value),precisionInt.Value)
				mreturn tempD
			end
			else
			begin
				valuestring = (@Json.JsonText)passedValue
				mreturn ^d((a)valuestring.Value,precisionInt.Value)
			end
		endmethod

		public method SerializeObject, void
			obj, @object
			serializer, @Json.ChannelSerializer
		proc
			if(obj .is. @DataObjectBase) then
				SerializeObject((@DataObjectBase)obj, serializer)
			else if(obj .is. @ArrayList) then
				SerializeObjectCollection((@ArrayList)obj, serializer)
			else if(obj .is. @a || obj .is. @d || obj .is. @id || obj .is. @string) then
				serializer.String(obj.ToString())
			else if(obj .is. @i) then
				serializer.Integer((i)obj)
			else
				throw new Exception("Attempted to serialize an unknown object type")
		endmethod

		public method DeserializeObject, @object
			obj, @Json.JsonObject
			out dataType, FieldDataType
			record
				dataTypeInt, @Json.JsonInt
		proc
			dataTypeInt = ((@Json.JsonInt)obj.GetProperty("DataType"))
			dataType = (FieldDataType)dataTypeInt.Value
			if(dataType == FieldDataType.DataObjectField) then
			begin
				mreturn DeserializeObject(obj, ^null)
			end
			else if(dataType == FieldDataType.DataObjectCollectionField) then
			begin
				mreturn DeserializeObjectCollection(obj)
			end
			else if(dataType == FieldDataType.AlphaField) then
			begin
				data textObject, @Json.JsonText, ((@Json.JsonText)obj.GetProperty("PassedValue"))
				mreturn textObject.Value
			end
			else if(dataType == FieldDataType.DecimalField) then
			begin
				mreturn ((@Json.JsonText)obj.GetProperty("PassedValue")).Value
			end
			else if(dataType == FieldDataType.ImpliedDecimal) then
			begin
				mreturn ((@Json.JsonText)obj.GetProperty("PassedValue")).Value
			end
			else if(dataType == FieldDataType.IntegerField)
			begin
				data intValue, i4, ((@Json.JsonInt)obj.GetProperty("PassedValue")).Value
				mreturn (@object)intValue
			end
		endmethod

		private method ReadCallBlock, boolean
			ttChannel, i
			frameHeader, i4
			record
				frameDataHandle, D_HANDLE
				jsonReader, @Json.Json
				parsedJson, @Json.JsonValue
		proc
			jsonReader = new Json.Json()
			writes(loggingChannel, "reading callblock: ")
			writes(loggingChannel, %string(frameHeader) + " callblock bytes expected")
			frameDataHandle = %mem_proc(DM_ALLOC, frameHeader)
again,		do gets(ttChannel, ^m(frameDataHandle), wait:100) [$err_timout=again] 
			until %rdlen(ttChannel) == frameHeader

			writes(loggingChannel, %string(%rdlen(ttChannel)) + ":" + %string(%rdtrm(ttChannel)))
			writes(loggingChannel, ^m(frameDataHandle) + "data read")
			parsedJson = jsonReader.ParseJson(^m(frameDataHandle))
			if(parsedJson .is. @Json.JsonObject) then
			begin
				data result, boolean, ProcessCallBlock((@Json.JsonObject)parsedJson, ttChannel)
				mreturn result
			end
			else
			begin
				data serializer = new Json.ChannelSerializer(ttChannel)
				writes(loggingChannel, "failed to read json request")
				serializer.MapOpen()
				serializer.String("IsError")
				serializer.Bool(true)
				serializer.String("Exception")
				serializer.String("failed to parse json request")
				serializer.MapClose()
				mreturn true
			end
			
		endmethod


		public method Dispatch, void
			ttChannel, i
			record aData
				frameHeader, d10
			record
				running, boolean
		proc
			;;read 10 bytes of data from input when its available
			;;read count of bytes from input (in chunks ideally) 
			;;look for the target routine name
			;;build rcb block for the call
			;;deserialize arguments based on the types in json
			;;make the call
			;;trap any exceptions
			try
			begin
				running = true
				while(running)
				begin
again,				do gets(ttChannel, aData, wait:100) [$err_timout=again] 
					until %rdlen(ttChannel) == 10
					puts(ttChannel, aData + %char(13) + %char(10))
					running = ReadCallBlock(ttChannel, (int)frameHeader)
				end
				writes(ttChannel, "Shutting down due to running == false")
			end
			catch(ex, @Exception)
			begin
				data serializer = new Json.ChannelSerializer(ttChannel)
				writes(loggingChannel, "FATAL ERROR in dispatcher + " + ex.ToString())
				serializer.MapOpen()
				serializer.String("IsError")
				serializer.Bool(true)
				serializer.String("Result")
				serializer.String(ex.ToString())
				serializer.MapClose()
			end
			endtry
		endmethod

		public method ProcessCallBlock, boolean
			jsonData, @Json.JsonObject
			responseChannel, i4
			record
				name, @string
				argArray, @Json.JsonArray
				serializer, @Json.ChannelSerializer
				dispatchStub, @RoutineStub
		proc
			;;we've been asked to shutdown so return false and let the outer loop take care of it
			if(jsonData.HasProperty("IsShutdownRequest") && ((@Json.JsonBoolean)jsonData.GetProperty("IsShutdownRequest")).Value)
			begin
				writes(responseChannel, "Shutting down due to request")
				mreturn false
			end


			serializer = new Json.ChannelSerializer(responseChannel)

			try
			begin
				;;we've been asked if we're alive
				if(jsonData.HasProperty("IsPingRequest") && ((@Json.JsonBoolean)jsonData.GetProperty("IsPingRequest")).Value) then
				begin
					serializer.MapOpen()
					serializer.String("IsAlive")
					serializer.Bool(true)
					serializer.MapClose()
					mreturn true
				end
				else if(jsonData.HasProperty("ProtocolVersion") && ((@Json.JsonText)jsonData.GetProperty("ProtocolVersion")).Value =="1.0")
				begin
					serializer.MapOpen()
					serializer.String("ProtocolSupported")
					serializer.Bool(true)
					serializer.MapClose()
					mreturn true
				end

				name = ((@Json.JsonText)jsonData.GetProperty("Name")).Value

				if(mDispatchStubs.TryGet(name, dispatchStub)) then
				begin
					dispatchStub.Dispatch(name, jsonData, serializer, this)
					mreturn true
				end
				else
				begin
					data arg, @Json.JsonObject
					data argArray, @ArrayList, new ArrayList()
					data argValueArray, [#]@Object
					data rcbid, i4
					data ii, i4, 0
					if(jsonData.HasProperty("Arguments"))
					begin
						data arg, @Json.JsonObject
						data ii = 0
						argArray = ((@Json.JsonArray)jsonData.GetProperty("Arguments")).arrayValues
					end
					argValueArray = new object[argArray.Count]
					rcbid = %rcb_create(argArray.Count) 
					xcall rcb_setfnc(rcbid, name)
					foreach arg in argArray as @Json.JsonObject
					begin
						data argType, FieldDataType
						data argLength, i4, 0
						data argPrecision, i4, 0
						incr ii
						;;the arguments need somewhere to live while we're building up the call so put them into this array
						argValueArray[ii] = DeserializeObject(arg, argType)
						if(argType != FieldDataType.DataObjectField && argType != FieldDataType.DataObjectCollectionField) then
						begin
							if(jsonData.HasProperty("DecimalPrecision"))
								argPrecision = ((@Json.JsonInt)jsonData.GetProperty("DecimalPrecision")).Value

							argLength = ((@Json.JsonInt)jsonData.GetProperty("ElementSize")).Value

							xcall rcb_setarg(rcbid, (n)argValueArray[ii], ii, (i)argType, argLength, argPrecision)
						end
						else
							xcall rcb_setarg(rcbid, argValueArray[ii], ii)
					end
					xcall rcb_call(rcbid) 
					ii = 0

					serializer.MapOpen()
					serializer.String("IsError")
					serializer.Bool(false)
					serializer.String("Result")
					serializer.MapOpen()
					serializer.String("ReturnParameters")
					serializer.ArrayOpen()

					foreach arg in argArray as @Json.JsonObject
					begin
						incr ii
						if(arg.HasProperty("ReturnParameter") && ((@Json.JsonBoolean)arg.GetProperty("ReturnParameter")).Value)
						begin
							serializer.MapOpen()
							serializer.String("Position")
							serializer.Integer(ii)
							serializer.String("Value")
							SerializeObject(argValueArray[ii], serializer)
							serializer.MapClose()
						end

					end
					serializer.ArrayClose()
					serializer.MapClose()
					serializer.MapClose()
				end
			end
			catch(ex, @Exception)
			begin
				;;TODO maybe this should be a specific type, we might need to do additional processing for certain exception types here
				serializer.MapOpen()
				serializer.String("IsError")
				serializer.Bool(true)
				serializer.String("Exception")
				serializer.String(ex.ToString())
				serializer.MapClose()
				mreturn false
			end
			endtry

			writes(responseChannel, "unhandled message")
			mreturn false
		endmethod

	endclass

	abstract class RoutineStub
		public abstract method Dispatch, void
			name, @string
			callFrame, @Json.JsonObject
			serializer, @Json.ChannelSerializer
			dispatcher, @RoutineDispatcher
		proc
		endmethod
	endclass

endnamespace