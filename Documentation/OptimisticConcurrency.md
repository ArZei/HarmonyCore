#Optimistic Concurrency
Optimistic concurrency is an alternative to locking and holding locks on records for the duration of a transaction only releasing the lock when you've written the updated contents of a record. Instead of locking, optimistic concurrency uses a concurrency token that is created or retrived after a record is read. When you're ready to update the record, using the concurrency token, check that the record hasnt changed since you read it. If the record hasnt changed, then its written. If the record has been changed, there are a few options for conflict resolution. Its possible to merge the record using hand written code, or you can just abort the transaction and try again. 

## Why not locks
Locks have been used in buisness critical applications for as long as buisnesses have been writing software. They are straightforward to think about and other than dead locks they tend to be trouble free. Unfortunately they are exclusive and mean there is a single point of bottleneck for a contested record. Even if a record is not contested, taking a lock requires more IO ops. All of this adds up to reduce your applications ability to scale up to servers with more CPU cores or more RAM. Operating over the network this effect is made worse because the that latency of a round trip to the server. 

## How
SDBMS is capable of returning Global RFA's for records that are read from ISAM files. Global RFA's or GRFA's are usable as a Concurrency Token. Additionally GRFA's are used where available as the ETag for any DataObject returned from an OData endpoint. This lets a client of our webservice to request data, and then make an update to a field, passing the ETag they recived from the original request. Using that concurrecny token, we validate that the record hasnt changed since it was read, then update it if it hasnt. If it has changed an event will be fired that allows your application to run custom code to merge the record changes into the current record or to just fail the transaction if that isnt possible.
