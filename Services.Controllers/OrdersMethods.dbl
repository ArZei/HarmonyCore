import System.Threading.Tasks
import System
import System.Collections.Generic
import System.Text
import Services
import Services.Models
import Harmony.Core.Interface
import Harmony.Core.EF.Extensions
import Microsoft.AspNetCore.Mvc
import Microsoft.AspNetCore.Authorization
import Harmony.Core.Context
import Harmony.OData
import Harmony.Core
import System.Linq

namespace Services.Controllers

    {Controller}
    {Authorize}
	public class OrdersMethods

        private readwrite property mDbContext, @Services.Models.DBContext
        private readwrite property mServiceProvider, @IServiceProvider

        ;;; <summary>
        ;;; Constructor
        ;;; </summary>
        ;;; <param name="aDbContext">DBContext supplied by dependency injection.</param>
        ;;; <param name="aServicesProvider">Services provider supplied by dependency injection.</param>
        public method OrdersMethods
            required in aDbContext, @Services.Models.DbContext
            required in aServiceProvider, @IServiceProvider
        proc
            mDbContext = aDbContext
            mServiceProvider = aServiceProvider
        endmethod

        public method CreateNewOrder, int
            required in aOrder, @Order
            ;;TODO: something wrong with the registration method when this parameter is of type ICollection it wrecks the EDM model for OrderItem
            required in aOrderItems, @List<OrderItem>
        proc
            ;;Validate inbound data (we're not a controller so we can't use ModelState!)

            if (aOrderItems.Count<1)
                throw new ApplicationException("No items were provided!")

            ;TODO: Need more data validation
            ;;Customer ID needs to be valid
            ;;Item ID's need to be valid
            ;;And more

            ;;Allocate the next available order number to the new order
            disposable data keyFactory = (@IPrimaryKeyFactory)mServiceProvider.GetService(^typeof(IPrimaryKeyFactory))
            keyFactory.AssignPrimaryKey(aOrder)

            ;;Propagate the new order number to the order items, and polulate line item numbers
            data item, @OrderItem
            data itemNumber = 0
            foreach item in aOrderItems
            begin
                item.OrderNumber = aOrder.OrderNumber
                item.ItemNumber = (itemNumber+=1)
            end

            ;;Save the new order
            mDbContext.Orders.Add(aOrder)
            mDbContext.OrderItems.AddRange(aOrderItems)
            mDbContext.SaveChanges(keyFactory)

            ;TODO: What happens if something fails?

            mreturn aOrder.OrderNumber

        endmethod

    endclass

	{Controller}
	{Authorize}
	public class ExternalCallContext extends DynamicCallProvider
		public method ExternalCallContext
			connection, @IDynamicCallConnection
			endparams
			parent(connection)
		proc

		endmethod
		{CallableMethodConfigurationAttribute(IsFunction=true, ReturnsFromEntitySet=true)}
		public async method GetAllCustomers, @Task<List<Customer>>
		proc
			;;force metadata to be loaded if its not
            DataObjectMetadataBase.LookupType(^typeof(Customer))
			data resultTpl = await CallMethod("GetAllCustomers", new List<Customer>(), string.Empty)
			mreturn ((@IEnumerable<Customer>)resultTpl.Item2[1]).ToList<Customer>()
		endmethod
	endclass
endnamespace
