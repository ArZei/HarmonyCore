import Harmony.OData.Adapter
import System.Threading.Tasks
import System
import System.Collections.Generic
import System.Text
import Services
import Services.Models
import Harmony.Core.Interface
import Harmony.Core.EF.Extensions
import Microsoft.AspNetCore.Mvc
import Microsoft.AspNet.OData
import Microsoft.AspNetCore.Authorization
import Harmony.Core.Context
import Harmony.OData
import Harmony.Core
import System.Linq
import Newtonsoft.Json.Linq

namespace Services.Controllers

    {Controller}
    {Authorize}
	public class OrdersMethods

        private readwrite property mDbContext, @Services.Models.DBContext
        private readwrite property mServiceProvider, @IServiceProvider

        ;;; <summary>
        ;;; Constructor
        ;;; </summary>
        ;;; <param name="aDbContext">DBContext supplied by dependency injection.</param>
        ;;; <param name="aServicesProvider">Services provider supplied by dependency injection.</param>
        public method OrdersMethods
            required in aDbContext, @Services.Models.DbContext
            required in aServiceProvider, @IServiceProvider
        proc
            mDbContext = aDbContext
            mServiceProvider = aServiceProvider
        endmethod

        public method CreateNewOrder, int
            required in aOrder, @Order
            ;;TODO: something wrong with the registration method when this parameter is of type ICollection it wrecks the EDM model for OrderItem
            required in aOrderItems, @List<OrderItem>
        proc
            ;;Validate inbound data (we're not a controller so we can't use ModelState!)

            if (aOrderItems.Count<1)
                throw new ApplicationException("No items were provided!")

            ;TODO: Need more data validation
            ;;Customer ID needs to be valid
            ;;Item ID's need to be valid
            ;;And more

            ;;Allocate the next available order number to the new order
            disposable data keyFactory = (@IPrimaryKeyFactory)mServiceProvider.GetService(^typeof(IPrimaryKeyFactory))
            keyFactory.AssignPrimaryKey(aOrder)

            ;;Propagate the new order number to the order items, and polulate line item numbers
            data item, @OrderItem
            data itemNumber = 0
            foreach item in aOrderItems
            begin
                item.OrderNumber = aOrder.OrderNumber
                item.ItemNumber = (itemNumber+=1)
            end

            ;;Save the new order
            mDbContext.Orders.Add(aOrder)
            mDbContext.OrderItems.AddRange(aOrderItems)
            mDbContext.SaveChanges(keyFactory)

            ;TODO: What happens if something fails?

            mreturn aOrder.OrderNumber

        endmethod

		{CallableMethodConfigurationAttribute(IsFunction=true, ReturnsFromEntitySet=true)}
		{EnableQuery()}
		public method FindAvailability, @List<Availability>
			{AdapterParameterAttribute}
			filter, @AvailabiltyFilter
		proc
			mreturn new List<Availability>() { new Availability() { PointsCost = 9999 } }
		endmethod


    endclass

	{Controller}
	{Authorize}
	public class ExternalCallContext extends DynamicCallProvider
		public method ExternalCallContext
			connection, @IDynamicCallConnection
			endparams
			parent(connection)
		proc

		endmethod
		{CallableMethodConfigurationAttribute(IsFunction=true, ReturnsFromEntitySet=true)}
		public async method GetAllCustomers, @Task<List<Customer>>
		proc
			;;force metadata to be loaded if its not
            DataObjectMetadataBase.LookupType(^typeof(Customer))
			data resultTpl = await CallMethod("GetAllCustomers", new List<Customer>(), string.Empty)
			mreturn ((@IEnumerable<Customer>)resultTpl.Item2[1]).ToList<Customer>()
		endmethod

		{CallableMethodConfigurationAttribute(IsFunction=true, ReturnsFromEntitySet=false)}
		public async method Arbitrario_MethodWithParameters, @Task<ArbitrarioReturnType>
		proc
			data intArray = new int[#] {5, 4, 3, 2, 1 }
			data resultTpl = await CallMethod("Arbitrario.MethodWithParameters", 5, "hello", new string[#] { "this", "is", "strings" }, (@object)intArray, new string[0])
			data returnToken = ((@JToken)resultTpl.Item1)
			mreturn new ArbitrarioReturnType() { ReturnCode = returnToken.ToObject<int>(), IntList = ((@IEnumerable<int>)resultTpl.Item2[4]).ToList(), StringList = ((@IEnumerable<string>)resultTpl.Item2[5]).ToList() }
        endmethod

        public async method Arbitrario_MethodWithParameters2, @Task<ArbitrarioReturnType>
            aNumber, int
            aString, @string
            aStringArray, [#]string
            aIntArray, [#]int
        proc
            data resultTpl = await CallMethod("Arbitrario.MethodWithParameters", aNumber, aString, aStringArray, aIntArray, new string[0])
            data returnToken = ((@JToken)resultTpl.Item1)
            mreturn new ArbitrarioReturnType() { ReturnCode = returnToken.ToObject<int>(), IntList = ((@IEnumerable<int>)resultTpl.Item2[4]).ToList(), StringList = ((@IEnumerable<string>)resultTpl.Item2[5]).ToList() }
        endmethod

		public class ArbitrarioReturnType
			public readwrite property ReturnCode, int
			public readwrite property IntList, @List<int>
			public readwrite property StringList, @List<string>
		endclass

    endclass


    public class AvailabilityController extends ODataController
    
        {CallableMethodConfigurationAttribute(IsFunction=true, ReturnsFromEntitySet=true)}
        {EnableQuery()}
        public method FindAvailability, @ActionResult<List<Availability>>
            {AdapterParameterAttribute}
            filter, @AvailabiltyFilter
        proc
            mreturn Ok(new List<Availability>() { new Availability() { PointsCost = 9999 } })
        endmethod

		{CallableMethodConfigurationAttribute(IsFunction=true, ReturnsFromEntitySet=true)}
		{EnableQuery()}
		public method FindFirstAvailability, @Availability
			{AdapterParameterAttribute}
			filter, @AvailabiltyFilter
		proc
			mreturn new Availability() { PointsCost = 9999 }
		endmethod

    endclass

endnamespace
