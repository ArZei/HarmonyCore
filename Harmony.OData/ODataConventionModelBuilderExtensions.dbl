import System
import System.Collections.Generic
import System.Text
import Microsoft.AspNet.OData.Builder
import System.Reflection
import System.Linq
import System.Threading.Tasks
import Harmony.OData.Adapter

namespace Harmony.OData

    public static class ODataConventionModelBuilderExtensions
        
        private static FunctionReturnsCollectionMethod, @MethodInfo
        private static FunctionReturnsMethod, @MethodInfo
        private static FunctionReturnsFromEntitySetMethod, @MethodInfo
        private static FunctionReturnsCollectionFromEntitySetMethod, @MethodInfo
        private static FunctionParameterMethod, @MethodInfo

        private static ActionReturnsCollectionMethod, @MethodInfo
        private static ActionReturnsMethod, @MethodInfo
        private static ActionReturnsFromEntitySetMethod, @MethodInfo
        private static ActionReturnsCollectionFromEntitySetMethod, @MethodInfo
        private static ActionParameterMethod, @MethodInfo

        static method ODataConventionModelBuilderExtensions
        proc
            data functionType = ^typeof(FunctionConfiguration)
            data actionType = ^typeof(ActionConfiguration)
            FunctionReturnsCollectionMethod = functionType.GetMethod("ReturnsCollection", new Type[0])
            FunctionReturnsMethod = functionType.GetMethod("Returns", new Type[0])
            FunctionReturnsFromEntitySetMethod = functionType.GetMethod("ReturnsFromEntitySet", new Type[#] { ^typeof(String) })
            FunctionReturnsCollectionFromEntitySetMethod = functionType.GetMethod("ReturnsCollectionFromEntitySet", new Type[#] { ^typeof(String) })
            FunctionParameterMethod = functionType.GetMethod("Parameter", new Type[#] { ^typeof(String) })

            ActionReturnsCollectionMethod = actionType.GetMethod("ReturnsCollection", new Type[0])
            ActionReturnsMethod = actionType.GetMethod("Returns", new Type[0])
            ActionReturnsFromEntitySetMethod = actionType.GetMethod("ReturnsFromEntitySet", new Type[#] { ^typeof(String) })
            ActionReturnsCollectionFromEntitySetMethod = actionType.GetMethod("ReturnsCollectionFromEntitySet", new Type[#] { ^typeof(String) })
            ActionParameterMethod = actionType.GetMethod("Parameter", new Type[#] { ^typeof(String) })
        endmethod


        public class EntityTypeWrapper<T(class)>
            {System.ComponentModel.DataAnnotations.Key}
            public readwrite property ID, int, 0
        endclass

        public static extension method AddMethod<T(class), EntityType(class)>, void
            builder, @ODataModelBuilder
            methodName, @string
            namespaceName, @string
            entityConfig, @object
            entitySetLookup, @Dictionary<Type, EntitySetConfiguration>
        proc
            data targetMethod = ^typeof(T).GetMethod(methodName)
            if(targetMethod == ^null)
                throw new MissingMethodException(^typeof(T).FullName, methodName)

            AddMethod<EntityType>(builder, targetMethod, namespaceName, entityConfig, entitySetLookup)
        endmethod

        private static method CreateFunctionConfig<EntityType(class)>, @FunctionConfiguration
            typeConfig, @object
            memberName, @string
        proc
            if(typeConfig .is. EntityTypeConfiguration<EntityType>) then
            begin
                data esetConfig = ((@EntityTypeConfiguration<EntityType>)typeConfig)
                mreturn esetConfig.Function(memberName)
            end
            else if(typeConfig .is. EntityCollectionConfiguration<EntityType>) then
            begin
                mreturn ((@EntityCollectionConfiguration<EntityType>)typeConfig).Function(memberName)
            end
            else
                throw new InvalidOperationException("Type config needs to be an EntityTypeConfiguration<EntityType> or EntityCollectionConfiguration<EntityType>")
            
        endmethod

        private static method CreateActionConfig<EntityType(class)>, @ActionConfiguration
            typeConfig, @object
            memberName, @string
        proc
            if(typeConfig .is. EntityTypeConfiguration<EntityType>) then
            begin
                mreturn ((@EntityTypeConfiguration<EntityType>)typeConfig).Action(memberName)
            end
            else if(typeConfig .is. EntityCollectionConfiguration<EntityType>) then
            begin
                mreturn ((@EntityCollectionConfiguration<EntityType>)typeConfig).Action(memberName)
            end
            else
                throw new InvalidOperationException("Type config needs to be an EntitySetConfiguration<EntityType> or EntityCollectionConfiguration<EntityType>")
            
        endmethod


        public static extension method AddMethod<EntityType(class)>, void
            builder, @ODataModelBuilder
            targetMethod, @MethodInfo
            namespaceName, @string
            typeConfig, @object
            entitySetLookup, @Dictionary<Type, EntitySetConfiguration>
        proc
            data callableMethodConfig, @CallableMethodConfigurationAttribute
            callableMethodConfig = targetMethod.GetCustomAttribute<CallableMethodConfigurationAttribute>(false)
            if(callableMethodConfig == ^null)
            begin
                callableMethodConfig = new CallableMethodConfigurationAttribute()
                if(entitySetLookup.ContainsKey(targetMethod.ReturnType))
                    callableMethodConfig.ReturnsFromEntitySet = true
            end


            data paramFunction, @MethodInfo
            data resultObject, @Object
            ;;need to also check for TransformRefOutParametersAttribute to determine the real return type of the routine
            if(callableMethodConfig.IsFunction) then
            begin
                data addedFunction, @FunctionConfiguration
                if(typeConfig != ^null) then
                begin
                    ;;TODO isolate compiler bug here
                    ;addedFunction = singletonConfig.EntityType.Function(targetMethod.Name)
                    addedFunction = CreateFunctionConfig<EntityType>(typeConfig, targetMethod.Name)
                end
                else
                    builder.Function(targetMethod.Name)
                MakeReturnType(targetMethod, callableMethodConfig, addedFunction)
                resultObject = addedFunction
                paramFunction = FunctionParameterMethod
            end
            else
            begin
                data addedAction, @ActionConfiguration
                if(typeConfig != ^null) then
                    addedAction = CreateActionConfig<EntityType>(typeConfig, targetMethod.Name)
                else
                    addedAction = builder.Action(targetMethod.Name)

                MakeReturnType(targetMethod, callableMethodConfig, addedAction)
                resultObject = addedAction
                paramFunction = ActionParameterMethod
            end

            data paramInfo, @ParameterInfo
            foreach paramInfo in targetMethod.GetParameters()
            begin
                data adapterAttribute = paramInfo.GetCustomAttribute<AdapterParameterAttribute>(false)
                if(adapterAttribute != ^null) then
                begin
                    ;;if its an adapter parameter we need to translate any fields/properties marked as parameters into the appropriate edm info
                    data prop, @PropertyInfo
                    foreach prop in paramInfo.ParameterType.GetProperties()
                    begin
                        data getter = prop.GetMethod
                        if(getter != ^null && getter.IsPublic && !getter.IsStatic)
                        begin
                            data paramAttr = prop.GetCustomAttribute<ParameterFieldAdapterAttribute>(false)
                            if(paramAttr != ^null)
                            begin
                                data paramConfig = ^as(paramFunction.MakeGenericMethod(new Type[#] { prop.PropertyType }).Invoke(resultObject, new Object[#] { paramAttr.EdmName }), @ParameterConfiguration)
                                if(paramAttr.IsOptional)
                                    paramConfig.Optional()
                            end
                        end
                    end
                end
                else
                    paramFunction.MakeGenericMethod(new Type[#] { paramInfo.ParameterType }).Invoke(resultObject, new Object[#] { paramInfo.Name })
            end

        endmethod


        ;;Use reflection on the provided generic type, find all of the public methods
        ;;make functions/actions depending on the return type and the presance of Harmony.OData.PureFunctionAttribute
        public static extension method AddMethods<T(class)>, void
            builder, @ODataModelBuilder
            namespaceName, @string
        proc
            data singletonConfig, @SingletonConfiguration<EntityTypeWrapper<T>>, String.IsNullOrWhiteSpace(namespaceName) ? ^null : builder.Singleton<EntityTypeWrapper<T>>(namespaceName)
            data entityConfig, @EntityTypeConfiguration<EntityTypeWrapper<T>>, builder.EntityType<EntityTypeWrapper<T>>()
            data targetType = ^typeof(T)
            data targetMethod, @MethodInfo
            HarmonySprocRoutingConvention.AddSprocDispatcher<T>(namespaceName)
            data entitySetLookup = new Dictionary<Type, EntitySetConfiguration>()
            data eSet, @EntitySetConfiguration
            foreach eSet in builder.EntitySets
            begin
                if(!entitySetLookup.ContainsKey(eSet.ClrType))
                    entitySetLookup.Add(eSet.ClrType, eSet)
            end

            foreach targetMethod in targetType.GetMethods()
            begin
                if(targetMethod.DeclaringType != targetType || targetMethod.IsSpecialName || targetMethod.Name.Contains("$"))
                    nextloop

                data securityAttribute = targetMethod.GetCustomAttribute<MethodSecurityAttribute>(false)
                if(securityAttribute != ^null && !((@MethodSecurityAttribute)securityAttribute).AllowAccess)
                begin
                    nextloop
                end

                AddMethod<EntityTypeWrapper<T>>(builder, targetMethod, namespaceName, entityConfig, entitySetLookup)

            end

            builder.Namespace = String.Empty
        endmethod

        private static method GetSequenceType, @Type
            type, @Type
        proc
            if(type.IsGenericType && type.GetGenericTypeDefinition() == ^typeof(IEnumerable<>))
                mreturn type.GenericTypeArguments.First()


            data implementsIEnumerable = type.GetInterfaces().FirstOrDefault(lambda(inter) { inter.IsGenericType && inter.GetGenericTypeDefinition() == ^typeof(IEnumerable<>) } )
            if (implementsIEnumerable != ^null) then
                mreturn implementsIEnumerable.GenericTypeArguments.First()
            else
                mreturn ^null
        endmethod

        private static method MakeReturnType, void
            methInfo, @MethodInfo
            callableConfig, @CallableMethodConfigurationAttribute
            funcConfig, @FunctionConfiguration
        proc
            data returnType, @Type
            data returnTypeIsCollection, boolean, false
            data returnTypeIsFromEntitySet, boolean, false
            data returnTypeIsCollectionFromEntitySet, boolean, false
            data taskClean = methInfo.ReturnType
            if(taskClean.IsGenericType && taskClean.GetGenericTypeDefinition() == ^typeof(Task<>))
            begin
                taskClean = taskClean.GetGenericArguments()[1]
            end

            if(taskClean.IsGenericType)
            begin
                data sequenceType = GetSequenceType(taskClean)
                if(sequenceType != ^null)
                begin
                    returnTypeIsCollection = true
                    returnType = sequenceType
                end
            end

            if(callableConfig.ReturnsFromEntitySet)
            begin
                if(returnTypeIsCollection) then
                    returnTypeIsCollectionFromEntitySet = true
                else
                    returnTypeIsFromEntitySet = true
            end


            if(returnTypeIsFromEntitySet) then
            begin
                FunctionReturnsFromEntitySetMethod.MakeGenericMethod(new Type[#] { returnType }).Invoke(funcConfig, new Object[0]) 
            end
            else if(returnTypeIsCollectionFromEntitySet) then
            begin
                FunctionReturnsCollectionFromEntitySetMethod.MakeGenericMethod(new Type[#] { returnType }).Invoke(funcConfig, new Object[#] { returnType.Name })
            end
            else if(returnTypeIsCollection) then
            begin
                FunctionReturnsCollectionMethod.MakeGenericMethod(new Type[#] { returnType }).Invoke(funcConfig, new Object[0])
            end
            else
            begin
                FunctionReturnsMethod.MakeGenericMethod(new Type[#] { returnType }).Invoke(funcConfig, new Object[0])
            end
            
        endmethod

        private static method MakeReturnType, void
            methInfo, @MethodInfo
            callableConfig, @CallableMethodConfigurationAttribute
            actionConfig, @ActionConfiguration
        proc
            data returnType, @Type, methInfo.ReturnType
            data returnTypeIsCollection, boolean, false
            data returnTypeIsFromEntitySet, boolean, false
            data returnTypeIsCollectionFromEntitySet, boolean, false
            if(methInfo.ReturnType.IsGenericType)
            begin
                data sequenceType = GetSequenceType(methInfo.ReturnType)
                if(sequenceType != ^null)
                begin
                    returnTypeIsCollection = true
                    returnType = sequenceType
                end
            end

            if(returnType == ^typeof(void))
                mreturn

            if(callableConfig.ReturnsFromEntitySet)
            begin
                if(returnTypeIsCollection) then
                    returnTypeIsCollectionFromEntitySet = true
                else
                    returnTypeIsFromEntitySet = true
            end


            if(returnTypeIsFromEntitySet) then
            begin
                ActionReturnsFromEntitySetMethod.MakeGenericMethod(new Type[#] { returnType }).Invoke(actionConfig, new Object[#] { returnType.Name }) 
            end
            else if(returnTypeIsCollectionFromEntitySet) then
            begin
                ActionReturnsCollectionFromEntitySetMethod.MakeGenericMethod(new Type[#] { returnType }).Invoke(actionConfig, new Object[#] { returnType.Name })
            end
            else if(returnTypeIsCollection) then
            begin
                ActionReturnsCollectionMethod.MakeGenericMethod(new Type[#] { returnType }).Invoke(actionConfig, new Object[0])
            end
            else
            begin
                ActionReturnsMethod.MakeGenericMethod(new Type[#] { returnType }).Invoke(actionConfig, new Object[0])
            end
            
        endmethod
    endclass

endnamespace
