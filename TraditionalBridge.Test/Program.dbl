
import Harmony.TraditionalBridge
import Json
import TraditionalBridge.Test
import TraditionalBridge

.ifdef D_VMS
.define LOG_EXTENSION ".log;1"
.else
.define LOG_EXTENSION ".log"
.endc

main
	record
		disp, @SampleXfplEnvDispatcher
        ttChan, i4
        processId, d10
        processName, a256
        logLevel, a1
        logLevelLength, int
        logLevelInt, int
	endrecord
proc
	try
	begin
		data jsn, @Json.Json, new Json.Json()
		data jsnValue, @Json.JsonValue
		data jsnObj, @Json.JsonObject
		data jsnArray, @Json.JsonArray
		data targetLogSettings, @LoggerScopeSettings, new LoggerScopeSettings()
		nop
		xcall flags(1907050020)
        open(ttChan=0, O, "TT:")

        ;;get the process number to create a unique log file name with
        xcall JBNO(processId)
        xcall JBNAM(processName)
        getlog("HARMONY_LOG_LEVEL", logLevel, logLevelLength)
        if(logLevelLength > 0) then
            logLevelInt = %integer(logLevel)
        else
            logLevelInt = 6 ;log almost everything

        TraditionalBridge.Logger.Instance = new TraditionalBridge.Logger(%atrim(processName) + "_" + %string(processId) + LOG_EXTENSION, logLevelInt, false)
		
		puts(ttChan, "READY" + %char(13)+ %char(10))

		disp = new SampleXfplEnvDispatcher()

		disp.Dispatch(ttChan)
	end
	
	catch(e, @Exception)
	begin
		if(TraditionalBridge.Logger.Instance != ^null)
			TraditionalBridge.Logger.Instance.Log("DISPATCHER EXITED with exception" + e.ToString())
	end
	endtry
	if(TraditionalBridge.Logger.Instance != ^null)
		TraditionalBridge.Logger.Instance.CloseLog()

endmain
